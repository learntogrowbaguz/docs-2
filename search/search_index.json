{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Iden3 Docs Welcome to the documentation site of the Iden3 project, future-proof tech stack for self-sovereign identity. Iden3 on GitHub Versatility of applications The main idea of the iden3 protocol is that each identity is self-soverign and can issue claims on another identity (which can be for an individual, an organisation or a system/machine). This simple and unique characteristics can lead to creation complex adaptive systems and the following use cases: Decentralised trust models / web-of-trust Decentralised ID verification / proof-of-personhood Decentralised voting systems Interaction with DeFi / dApps / Web3 Decentralised payment identifiers Private access control Authentication and authorisation Signing documents and private messaging Supply chain and IoT NFT ownership Iden3 protocol libraries Crypto library ( go-iden3-crypto ) Implementation of Poseidon hash and Baby JubJub Eliptic curve Merkle tree sql library ( go-merkletree-sql ) Implementation of Sparse Merkle tree Core library ( go-iden3-core ) Identity core primitives Circuits ( circuits ) Identity circuits Go-circuits ( go-circuits ) Library for transformation go-core primitives to json inputs for identity circuits Prover server ( prover-server ) Wrapper on snarkjs for ZK proof generation Authorization library ( go-iden3-auth ) Library for authentication with zkp verification (edited)","title":"Home"},{"location":"#iden3-docs","text":"Welcome to the documentation site of the Iden3 project, future-proof tech stack for self-sovereign identity.","title":"Iden3 Docs"},{"location":"#iden3-on-github","text":"","title":"Iden3 on GitHub"},{"location":"#versatility-of-applications","text":"The main idea of the iden3 protocol is that each identity is self-soverign and can issue claims on another identity (which can be for an individual, an organisation or a system/machine). This simple and unique characteristics can lead to creation complex adaptive systems and the following use cases: Decentralised trust models / web-of-trust Decentralised ID verification / proof-of-personhood Decentralised voting systems Interaction with DeFi / dApps / Web3 Decentralised payment identifiers Private access control Authentication and authorisation Signing documents and private messaging Supply chain and IoT NFT ownership","title":"Versatility of applications"},{"location":"#iden3-protocol-libraries","text":"Crypto library ( go-iden3-crypto ) Implementation of Poseidon hash and Baby JubJub Eliptic curve Merkle tree sql library ( go-merkletree-sql ) Implementation of Sparse Merkle tree Core library ( go-iden3-core ) Identity core primitives Circuits ( circuits ) Identity circuits Go-circuits ( go-circuits ) Library for transformation go-core primitives to json inputs for identity circuits Prover server ( prover-server ) Wrapper on snarkjs for ZK proof generation Authorization library ( go-iden3-auth ) Library for authentication with zkp verification (edited)","title":"Iden3 protocol libraries"},{"location":"basics/getting-started/","text":"Getting Started Zero-knowledge proofs If you want to get started writing zero-knowledge proofs, have a look at circom and snarkjs guide . It starts by covering the various techniques to write circuits for zero-knowledge proofs, then moves on to creating and verifying a proof off-chain, and finishes off by showing you how to do the same thing on-chain with Ethereum. Services and protocols To get started with any of our services/protocols, have a look here .","title":"Getting started"},{"location":"basics/getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"basics/getting-started/#zero-knowledge-proofs","text":"If you want to get started writing zero-knowledge proofs, have a look at circom and snarkjs guide . It starts by covering the various techniques to write circuits for zero-knowledge proofs, then moves on to creating and verifying a proof off-chain, and finishes off by showing you how to do the same thing on-chain with Ethereum.","title":"Zero-knowledge proofs"},{"location":"basics/getting-started/#services-and-protocols","text":"To get started with any of our services/protocols, have a look here .","title":"Services and protocols"},{"location":"basics/introduction/","text":"Introduction Identity is a uniquely human concept. It is that ineffable \u201cI\u201d of self-consciousness, something that is understood worldwide by every person living in every culture. As Ren\u00e9 Descartes said, Cogito ergo sum \u2014 I think, therefore I am. Source What constitutes your identity? What makes you who you are? What is it about you that distinguishes you from others? Philosophers have argued over these questions since the beginning of civilization. Suffice to say there are no simple answers. Identity is a difficult concept to pin down. Nevertheless, we don't need a precise definition to see that there are problems with how modern society thinks about identity. In the words of Christopher Allen : Today, nations and corporations conflate driver\u2019s licenses, social security cards, and other state-issued credentials with identity; this is problematic because it suggests a person can lose his very identity if a state revokes his credentials or even if he just crosses state borders. I think, but I am not. How can we improve on this? It's clear we're at an inflection point with respect to how the digital world interacts with the physical world. The legacy systems of the physical world have not kept up with the digital world's rising importance to it . As both worlds continue merging, this will have to change. This gives us an opportunity to create systems -- from the ground up -- that bridge the two. Systems that operate with a different conception of identity. If we design them well, they will allow us to redefine how modern society thinks about identity. Perhaps getting us closer to that ineffable \"I\" of self-consciousness. At Iden3 we're focused on building the tools and developing the protocols to make this happen .","title":"Introduction"},{"location":"basics/introduction/#introduction","text":"Identity is a uniquely human concept. It is that ineffable \u201cI\u201d of self-consciousness, something that is understood worldwide by every person living in every culture. As Ren\u00e9 Descartes said, Cogito ergo sum \u2014 I think, therefore I am. Source What constitutes your identity? What makes you who you are? What is it about you that distinguishes you from others? Philosophers have argued over these questions since the beginning of civilization. Suffice to say there are no simple answers. Identity is a difficult concept to pin down. Nevertheless, we don't need a precise definition to see that there are problems with how modern society thinks about identity. In the words of Christopher Allen : Today, nations and corporations conflate driver\u2019s licenses, social security cards, and other state-issued credentials with identity; this is problematic because it suggests a person can lose his very identity if a state revokes his credentials or even if he just crosses state borders. I think, but I am not. How can we improve on this? It's clear we're at an inflection point with respect to how the digital world interacts with the physical world. The legacy systems of the physical world have not kept up with the digital world's rising importance to it . As both worlds continue merging, this will have to change. This gives us an opportunity to create systems -- from the ground up -- that bridge the two. Systems that operate with a different conception of identity. If we design them well, they will allow us to redefine how modern society thinks about identity. Perhaps getting us closer to that ineffable \"I\" of self-consciousness. At Iden3 we're focused on building the tools and developing the protocols to make this happen .","title":"Introduction"},{"location":"basics/key-concepts/","text":"Key concepts Identity At iden3, our goal is to democratize identity. We believe that everyone should be empowered to become their own certification authority . What do we mean by identity? An identity can be a person, a company, an organization, a DAO , a government. An identity can even be a thing: a chair, a room, a bot... When we talk about identities we are referring to identities as accounts. Generally speaking, these accounts are going to be smart contracts. So you can think of identities as smart contracts , where the address of the contract is the identifier of that identity. Key takeaways: Anything can be an identity One person can define and have many identities In Ethereum, an identity is an account or a smart contract Claims An identity can provide a claim. You can think of a claim as a statement: something an identity is saying. Most of the time, these statements refer to other identities. In other words claims usually create relations between identities. For example, when a university (identity) says that a student (identity) has a degree, this is a statement (claim) about the student. This statement creates a relation between the student and the university. Claims can be public or private. And it turns out that almost anything we say or do can be thought of as a claim. Company invoices, Facebook likes, email messages, can all be thought of as claims. Examples of claims A certificate (e.g. birth certificate) A debt recognition An invoice An Instagram \"Like\" An endorsement (reputation) An email A driving license A role in a company ... Almost anything! Direct claims If an identity wants to create many claims, they can put them all in a database, construct a Merkle tree of that database, and just publish (with a transaction) the root of the Merkle tree on-chain. If the identity wants to update the claims later, they repeat the same process and just publish the new root of the Merkle tree. For example, one could imagine a government adding/modifying millions of claims in a single transaction. Indirect claims While direct claims scale really well for identities that make a lot of claims (since millions of claims can be batched in a single transaction), the average user will probably only need to make a few claims a day, and so won't benefit from this batching. This is where indirect claims come in handy. Instead of having to pay gas everytime to update the Merkle root on-chain, indirect claims allow users to send claims off-chain to a relayer . The idea is that with relayers, millions of users can create millions of claims on mainnet without spending any gas (since the relayer is responsible for batching the claims and publishing the transactions). On top of this, using zero knowledge proofs we can ensure that the relayer is trustless. In other words we can make sure the relayer can't lie about the claims we sent them. The worst they can do is not publish them (and if this happens we as the user always have the choice to change relayers). Zero knowledge proofs In cryptography, a zero-knowledge proof or zero-knowledge protocol is a method by which one party (the prover) can prove to another party (the verifier) that they know a value x, without conveying any information apart from the fact that they know the value x. Source In other words, zero-knowledge proofs allow us to prove something specific without revealing any extra information. Why do we care? Simply put, when we're talking about claims, sometimes we want to prove things in a private way. Examples Nightclub entry Say you want to enter a nightclub, and you need to prove to the bouncer that you are over 18. But you don't want to reveal to him your name, address, or anything else that's not relevant. With a zero-knowledge proof you can prove that you hold the key that belongs to an identity that the state says is over 18, without revealing anything else about that identity. ICO participation Say an ICO is only available to KYC or authorized users. With ZK proofs you can prove that you are an authorized person to participate in the ICO without revealing who you are or how much you spent. Anonymous Voting Similar to the above, ZK proofs allow you to prove that you are an eligible identity, without revealing your identity. Non-reusable proofs A non-reusable proof is a received proof that is not valid to send to a third identity. For example, imagine that you belong to a political party, P. And P has made a private claim that you belong to it. Say that you want to prove to another identity that you belong to P, but you don't want that other identity to be able to pass on that proof to others. In other words, you want to make sure the proof stays between the two of you. We can do this using zero-knowledge proofs. How? To prove something -- let's call it A -- we can create a new proof B that is valid either if A is valid or we know the private key of the recipient, R. Clearly we don't know R's private key, so when we share a valid proof B with R, R knows that A must be valid. To see why B is non-reusable. Suppose R wants to share B with another recipient R'. Now, from the perspective of R', B is valid either if A is valid or R knows her own private key. But since R clearly knows her own private key, R' can't tell whether A is valid. zk-snarks You can think of zk-snarks as an efficient way to produce zero-knowledge proofs. Proofs that are short enough to publish to a blockchain and that can be read later by a verifier. Merkle trees A Merkle tree is a binary tree built using hash pointers (if you're unfamiliar with what a hash pointer or function is, see the definitions section at the bottom of the page). We care about Merkle trees because we want to build a data structure that: Can store lots of data ( scalability ) Makes it easy to prove that some data exists ( proof of membership ) Allows us to check that data hasn't been altered ( tamper resistance ) Merkle trees satisfy these three properties. Specification Before we take a closer look at the above properties, let's go through how to build a Merkle tree given some data. Suppose we have a number of blocks containing data. And that these blocks make up the leaves of our tree. The first step is to create a parent node for each data block. These parent nodes make up the next level in the tree and store the hash of their descendent data block. Next, we group the parent nodes into pairs, and store their hashes one level up the tree. We continue doing this until we reach a single block, the root of the tree. Tamper resistance It turns out that any attempt to tamper with any piece of data can be detected by simply remembering the hash at the root of the tree. To understand why this is the case, let\u2019s look at what happens if an adversary wants to tamper with a data block. If an adversary tampers with a block at the leaf of our tree. That will cause the hash in the node that\u2019s one level up to not match. So he\u2019ll have to tamper with that too. Which means, he\u2019ll have to tamper with the node one level up from there. And so on\u2026 Eventually he\u2019ll get to the root. If he tries to tamper with the root, we\u2019ll know because this is the node we\u2019ve kept track of. Proof of membership Merkle trees allow us to quickly check membership (through a neat mechanism known as Merkle proofs).. What do we mean by that? Say that, as usual, we remember just the root (on-chain). And we want to prove that a certain data block\u200a-\u200adata0, say\u200a-\u200ais a member of the Merkle tree. All we need are the blocks on the path from the data block to the root. And each of data0's siblings on the way up the path. We can ignore the rest of the tree, as these blocks are enough to allow us to verify the hashes all the way up to the root of the tree. How exactly? The idea is to recalculate the root by recursively hashing the data we want to prove exists. If the calculated root is equal to the on-chain root, this proves the data block exists in the Merkle tree. In our case, we start by calculating the hash of data0 and storing it in the block labelled 0. We then calculate the hash of the hash of data0 concatenated with the hash of data1\u200a-\u200ain other words, the hash of the concatenation of blocks 0 and 1\u200a-\u200aand store it in block 4. Finally, we calculate the hash of blocks 4 and 5 to obtain the recalculated root. If the calculated root is equal to the on-chain root, we\u2019ve proven that data0 exists in the Merkle tree. In technical terms: This means that if there are n nodes in the tree, only about log(n) items need to be shown. And since each step just requires computing the hash of the child block, it takes about log(n) time for us to verify it. And so even if the Merkle tree contains a very large number of blocks, we can still prove membership in a relatively short time. Verification thus runs in time and space that\u2019s logarithmic in the number of nodes in the tree. Source (pg 35) Scalability Storing data on a blockchain is expensive. Merkle trees help us minimize the amount of data stored on chain. How so? As we saw in the previous sections, to ensure tamper resistance and proof of membership we only need to store the root of the tree, not the whole tree. This means that, no matter how big the tree is, the only piece of data we actually need to store on chain is the root. Sparse Merkle trees At iden3 we actually use a slightly more complex data structure called a sparse Merkle tree. A sparse Merkle tree is like a standard Merkle tree, except the contained data is indexed, and each data block is placed at the leaf that corresponds to that block's index. In addition to inheriting the tamper-resistance and proof-of-membership properties from normal Merkle trees, sparse Merkle trees make it easy to prove that some data doesn\u2019t exist ( proof of non-membership ). Proof of non-membership Say that this time we only have two pieces of data -- data0 and data3 -- with indices 0 and 3 respectively. To construct a sparse Merkle tree, we populate the 0th and 3rd leaves with this data, leaving the 1st and 2nd leaves empty. Well.. almost empty. To be precise, we fill the 1st and 2nd leaves in with a special placeholder value like null . With this placeholder in place, we can now build up the rest of the tree. Now, what happens if we want to prove that a piece of (indexed) data -- data2 , say -- is not a member of this tree? Thanks to the way our data is indexed, proving that data2 is not a member of the tree is equivalent to proving that the value of the leaf at index 2 is null ! Put another way, proving non-membership of a data block is equivalent to proving membership of null (a simple Merkle proof). And, as we saw in our previous post, doing this efficiently is a basic property of a Merkle tree. Summary In sum, by indexing data and leaving leaves empty, sparse Merkle trees allow us to reframe proofs of non-membership into proofs of membership (a.k.a Merkle proofs), making it easy to prove that some data does not exist. One drawback to sparse Merkle trees is that they are really big. This means that, without optimizations, read and write operations can be quite inefficient. For exampe: a sparse Merkle tree usually has 2^256 leaves vs 2^32 for a normal Merkle tree. This means naive implementations require 256 operations to read or write (vs 32). Luckily, however, these sorts of inefficiencies are largely illusory. Since fairly simple optimizations exist to get around them! Note: while we won't get into the details here, one of the keys to these optimisations is that sparse Merkle trees are well, mostly sparse. This means many of the subtrees will end up being zero subtrees. Since H(0), H(H(0)), H(H(H(0))), and so on, are all constant values, the zero-subtrees can be cached (calculated once, stored, and then omitted from Merkle proofs), greatly reducing the size of computations. Why we use Merkle trees at iden3 At iden3, one of our major goals is scalability. Specifically, we believe anybody should be able to create as many identities as they want. And that any identity should be able to generate as many claims as they want. Imagine if you had to make a new transaction to the blockchain every time you wanted to make a new claim? Even worse, imagine you're a government and you're responsible for making millions of claims every day... To achieve this goal requires minimizing the amount of data stored on chain. This is where Merkle trees come in. Even if you're a government that's making millions of claims a day, you can just contruct a tree (off chain) with each claim as a separate data block, and simply calculate and store the root on chain. In other words, Merkle trees allow prolific claim generators to add/modify millions of claims in a single transaction. This makes it easy to scale claims. Definitions Hash functions A hash function basically maps an input string of any size to an output string of a fixed size. It must be efficiently computable (by that we mean that for any given input string, we can figure out the output of the hash function in a reasonable amount of time. More technically, computing the hash of an n\u2010bit string should have a running time that is O(n). For a hash function to be cryptographically secure, it must have three additional properties: Collision resistance Hiding Puzzle-friendliness While we won't get into the details here, let's briefly discuss what each of these properties mean. Collision resistance means that nobody can find two inputs that map to the same output. Hiding means that given an output there's no feasible way to figure out the input that generated it. Puzzle-friendliness is a little more complicated. Intuitively it means it's very hard to target the hash function to come out to some particular output value y. Don't worry if you don't see why this property is useful, for our purposes, it isn't very important. Hash pointers A hash pointer is simply a pointer to where some information is stored together with a cryptographic hash of the information. A pointer gives you a way to retrieve the information, whereas a hash pointer also gives you a way to verify that the information hasn\u2019t changed. In other words, a hash pointer is a pointer to where data is stored together with a cryptographic hash of the value of that data at some fixed point in time. If at some point in the future, we want to check the data hasn't changed, we simply hash the data again and check that the new output (cryptographic hash) matches the previous output. This works because we know by the collision resistance property of the hash function, that nobody can find two inputs that map to the same output. So if the output is the same, the input must also have been the same.","title":"Key concepts"},{"location":"basics/key-concepts/#key-concepts","text":"","title":"Key concepts"},{"location":"basics/key-concepts/#identity","text":"At iden3, our goal is to democratize identity. We believe that everyone should be empowered to become their own certification authority . What do we mean by identity? An identity can be a person, a company, an organization, a DAO , a government. An identity can even be a thing: a chair, a room, a bot... When we talk about identities we are referring to identities as accounts. Generally speaking, these accounts are going to be smart contracts. So you can think of identities as smart contracts , where the address of the contract is the identifier of that identity. Key takeaways: Anything can be an identity One person can define and have many identities In Ethereum, an identity is an account or a smart contract","title":"Identity"},{"location":"basics/key-concepts/#claims","text":"An identity can provide a claim. You can think of a claim as a statement: something an identity is saying. Most of the time, these statements refer to other identities. In other words claims usually create relations between identities. For example, when a university (identity) says that a student (identity) has a degree, this is a statement (claim) about the student. This statement creates a relation between the student and the university. Claims can be public or private. And it turns out that almost anything we say or do can be thought of as a claim. Company invoices, Facebook likes, email messages, can all be thought of as claims.","title":"Claims"},{"location":"basics/key-concepts/#examples-of-claims","text":"A certificate (e.g. birth certificate) A debt recognition An invoice An Instagram \"Like\" An endorsement (reputation) An email A driving license A role in a company ... Almost anything!","title":"Examples of claims"},{"location":"basics/key-concepts/#direct-claims","text":"If an identity wants to create many claims, they can put them all in a database, construct a Merkle tree of that database, and just publish (with a transaction) the root of the Merkle tree on-chain. If the identity wants to update the claims later, they repeat the same process and just publish the new root of the Merkle tree. For example, one could imagine a government adding/modifying millions of claims in a single transaction.","title":"Direct claims"},{"location":"basics/key-concepts/#indirect-claims","text":"While direct claims scale really well for identities that make a lot of claims (since millions of claims can be batched in a single transaction), the average user will probably only need to make a few claims a day, and so won't benefit from this batching. This is where indirect claims come in handy. Instead of having to pay gas everytime to update the Merkle root on-chain, indirect claims allow users to send claims off-chain to a relayer . The idea is that with relayers, millions of users can create millions of claims on mainnet without spending any gas (since the relayer is responsible for batching the claims and publishing the transactions). On top of this, using zero knowledge proofs we can ensure that the relayer is trustless. In other words we can make sure the relayer can't lie about the claims we sent them. The worst they can do is not publish them (and if this happens we as the user always have the choice to change relayers).","title":"Indirect claims"},{"location":"basics/key-concepts/#zero-knowledge-proofs","text":"In cryptography, a zero-knowledge proof or zero-knowledge protocol is a method by which one party (the prover) can prove to another party (the verifier) that they know a value x, without conveying any information apart from the fact that they know the value x. Source In other words, zero-knowledge proofs allow us to prove something specific without revealing any extra information. Why do we care? Simply put, when we're talking about claims, sometimes we want to prove things in a private way.","title":"Zero knowledge proofs"},{"location":"basics/key-concepts/#examples","text":"","title":"Examples"},{"location":"basics/key-concepts/#nightclub-entry","text":"Say you want to enter a nightclub, and you need to prove to the bouncer that you are over 18. But you don't want to reveal to him your name, address, or anything else that's not relevant. With a zero-knowledge proof you can prove that you hold the key that belongs to an identity that the state says is over 18, without revealing anything else about that identity.","title":"Nightclub entry"},{"location":"basics/key-concepts/#ico-participation","text":"Say an ICO is only available to KYC or authorized users. With ZK proofs you can prove that you are an authorized person to participate in the ICO without revealing who you are or how much you spent.","title":"ICO participation"},{"location":"basics/key-concepts/#anonymous-voting","text":"Similar to the above, ZK proofs allow you to prove that you are an eligible identity, without revealing your identity.","title":"Anonymous Voting"},{"location":"basics/key-concepts/#non-reusable-proofs","text":"A non-reusable proof is a received proof that is not valid to send to a third identity. For example, imagine that you belong to a political party, P. And P has made a private claim that you belong to it. Say that you want to prove to another identity that you belong to P, but you don't want that other identity to be able to pass on that proof to others. In other words, you want to make sure the proof stays between the two of you. We can do this using zero-knowledge proofs. How? To prove something -- let's call it A -- we can create a new proof B that is valid either if A is valid or we know the private key of the recipient, R. Clearly we don't know R's private key, so when we share a valid proof B with R, R knows that A must be valid. To see why B is non-reusable. Suppose R wants to share B with another recipient R'. Now, from the perspective of R', B is valid either if A is valid or R knows her own private key. But since R clearly knows her own private key, R' can't tell whether A is valid.","title":"Non-reusable proofs"},{"location":"basics/key-concepts/#zk-snarks","text":"You can think of zk-snarks as an efficient way to produce zero-knowledge proofs. Proofs that are short enough to publish to a blockchain and that can be read later by a verifier.","title":"zk-snarks"},{"location":"basics/key-concepts/#merkle-trees","text":"A Merkle tree is a binary tree built using hash pointers (if you're unfamiliar with what a hash pointer or function is, see the definitions section at the bottom of the page). We care about Merkle trees because we want to build a data structure that: Can store lots of data ( scalability ) Makes it easy to prove that some data exists ( proof of membership ) Allows us to check that data hasn't been altered ( tamper resistance ) Merkle trees satisfy these three properties.","title":"Merkle trees"},{"location":"basics/key-concepts/#specification","text":"Before we take a closer look at the above properties, let's go through how to build a Merkle tree given some data. Suppose we have a number of blocks containing data. And that these blocks make up the leaves of our tree. The first step is to create a parent node for each data block. These parent nodes make up the next level in the tree and store the hash of their descendent data block. Next, we group the parent nodes into pairs, and store their hashes one level up the tree. We continue doing this until we reach a single block, the root of the tree.","title":"Specification"},{"location":"basics/key-concepts/#tamper-resistance","text":"It turns out that any attempt to tamper with any piece of data can be detected by simply remembering the hash at the root of the tree. To understand why this is the case, let\u2019s look at what happens if an adversary wants to tamper with a data block. If an adversary tampers with a block at the leaf of our tree. That will cause the hash in the node that\u2019s one level up to not match. So he\u2019ll have to tamper with that too. Which means, he\u2019ll have to tamper with the node one level up from there. And so on\u2026 Eventually he\u2019ll get to the root. If he tries to tamper with the root, we\u2019ll know because this is the node we\u2019ve kept track of.","title":"Tamper resistance"},{"location":"basics/key-concepts/#proof-of-membership","text":"Merkle trees allow us to quickly check membership (through a neat mechanism known as Merkle proofs).. What do we mean by that? Say that, as usual, we remember just the root (on-chain). And we want to prove that a certain data block\u200a-\u200adata0, say\u200a-\u200ais a member of the Merkle tree. All we need are the blocks on the path from the data block to the root. And each of data0's siblings on the way up the path. We can ignore the rest of the tree, as these blocks are enough to allow us to verify the hashes all the way up to the root of the tree. How exactly? The idea is to recalculate the root by recursively hashing the data we want to prove exists. If the calculated root is equal to the on-chain root, this proves the data block exists in the Merkle tree. In our case, we start by calculating the hash of data0 and storing it in the block labelled 0. We then calculate the hash of the hash of data0 concatenated with the hash of data1\u200a-\u200ain other words, the hash of the concatenation of blocks 0 and 1\u200a-\u200aand store it in block 4. Finally, we calculate the hash of blocks 4 and 5 to obtain the recalculated root. If the calculated root is equal to the on-chain root, we\u2019ve proven that data0 exists in the Merkle tree. In technical terms: This means that if there are n nodes in the tree, only about log(n) items need to be shown. And since each step just requires computing the hash of the child block, it takes about log(n) time for us to verify it. And so even if the Merkle tree contains a very large number of blocks, we can still prove membership in a relatively short time. Verification thus runs in time and space that\u2019s logarithmic in the number of nodes in the tree. Source (pg 35)","title":"Proof of membership"},{"location":"basics/key-concepts/#scalability","text":"Storing data on a blockchain is expensive. Merkle trees help us minimize the amount of data stored on chain. How so? As we saw in the previous sections, to ensure tamper resistance and proof of membership we only need to store the root of the tree, not the whole tree. This means that, no matter how big the tree is, the only piece of data we actually need to store on chain is the root.","title":"Scalability"},{"location":"basics/key-concepts/#sparse-merkle-trees","text":"At iden3 we actually use a slightly more complex data structure called a sparse Merkle tree. A sparse Merkle tree is like a standard Merkle tree, except the contained data is indexed, and each data block is placed at the leaf that corresponds to that block's index. In addition to inheriting the tamper-resistance and proof-of-membership properties from normal Merkle trees, sparse Merkle trees make it easy to prove that some data doesn\u2019t exist ( proof of non-membership ).","title":"Sparse Merkle trees"},{"location":"basics/key-concepts/#proof-of-non-membership","text":"Say that this time we only have two pieces of data -- data0 and data3 -- with indices 0 and 3 respectively. To construct a sparse Merkle tree, we populate the 0th and 3rd leaves with this data, leaving the 1st and 2nd leaves empty. Well.. almost empty. To be precise, we fill the 1st and 2nd leaves in with a special placeholder value like null . With this placeholder in place, we can now build up the rest of the tree. Now, what happens if we want to prove that a piece of (indexed) data -- data2 , say -- is not a member of this tree? Thanks to the way our data is indexed, proving that data2 is not a member of the tree is equivalent to proving that the value of the leaf at index 2 is null ! Put another way, proving non-membership of a data block is equivalent to proving membership of null (a simple Merkle proof). And, as we saw in our previous post, doing this efficiently is a basic property of a Merkle tree.","title":"Proof of non-membership"},{"location":"basics/key-concepts/#summary","text":"In sum, by indexing data and leaving leaves empty, sparse Merkle trees allow us to reframe proofs of non-membership into proofs of membership (a.k.a Merkle proofs), making it easy to prove that some data does not exist. One drawback to sparse Merkle trees is that they are really big. This means that, without optimizations, read and write operations can be quite inefficient. For exampe: a sparse Merkle tree usually has 2^256 leaves vs 2^32 for a normal Merkle tree. This means naive implementations require 256 operations to read or write (vs 32). Luckily, however, these sorts of inefficiencies are largely illusory. Since fairly simple optimizations exist to get around them! Note: while we won't get into the details here, one of the keys to these optimisations is that sparse Merkle trees are well, mostly sparse. This means many of the subtrees will end up being zero subtrees. Since H(0), H(H(0)), H(H(H(0))), and so on, are all constant values, the zero-subtrees can be cached (calculated once, stored, and then omitted from Merkle proofs), greatly reducing the size of computations.","title":"Summary"},{"location":"basics/key-concepts/#why-we-use-merkle-trees-at-iden3","text":"At iden3, one of our major goals is scalability. Specifically, we believe anybody should be able to create as many identities as they want. And that any identity should be able to generate as many claims as they want. Imagine if you had to make a new transaction to the blockchain every time you wanted to make a new claim? Even worse, imagine you're a government and you're responsible for making millions of claims every day... To achieve this goal requires minimizing the amount of data stored on chain. This is where Merkle trees come in. Even if you're a government that's making millions of claims a day, you can just contruct a tree (off chain) with each claim as a separate data block, and simply calculate and store the root on chain. In other words, Merkle trees allow prolific claim generators to add/modify millions of claims in a single transaction. This makes it easy to scale claims.","title":"Why we use Merkle trees at iden3"},{"location":"basics/key-concepts/#definitions","text":"","title":"Definitions"},{"location":"basics/key-concepts/#hash-functions","text":"A hash function basically maps an input string of any size to an output string of a fixed size. It must be efficiently computable (by that we mean that for any given input string, we can figure out the output of the hash function in a reasonable amount of time. More technically, computing the hash of an n\u2010bit string should have a running time that is O(n). For a hash function to be cryptographically secure, it must have three additional properties: Collision resistance Hiding Puzzle-friendliness While we won't get into the details here, let's briefly discuss what each of these properties mean. Collision resistance means that nobody can find two inputs that map to the same output. Hiding means that given an output there's no feasible way to figure out the input that generated it. Puzzle-friendliness is a little more complicated. Intuitively it means it's very hard to target the hash function to come out to some particular output value y. Don't worry if you don't see why this property is useful, for our purposes, it isn't very important.","title":"Hash functions"},{"location":"basics/key-concepts/#hash-pointers","text":"A hash pointer is simply a pointer to where some information is stored together with a cryptographic hash of the information. A pointer gives you a way to retrieve the information, whereas a hash pointer also gives you a way to verify that the information hasn\u2019t changed. In other words, a hash pointer is a pointer to where data is stored together with a cryptographic hash of the value of that data at some fixed point in time. If at some point in the future, we want to check the data hasn't changed, we simply hash the data again and check that the new output (cryptographic hash) matches the previous output. This works because we know by the collision resistance property of the hash function, that nobody can find two inputs that map to the same output. So if the output is the same, the input must also have been the same.","title":"Hash pointers"},{"location":"basics/more-on-identity/","text":"More on decentralized identity Why does identity matter? In the words of Vitalik : Mechanisms that do not rely on identity cannot solve the problem of concentrated interests outcompeting dispersed communities; an identity-free mechanism that empowers distributed communities cannot avoid over-empowering centralized plutocrats pretending to be distributed communities. In other words, without an identity mechanism, one can't ensure one human one address, or one human one vote. This means that however you structure the rules of the system, those with the most resources will be able to game it. How is the existing system failing us? In recent times, identities have been verified by credentials such as a passport or social network account issued by a central authority (usually a state or corporation). However, as noted in Verifying Identity as a Social Intersection , such identity systems have several interrelated flaws: They are insecure . Crucial data such as an ID number constantly has to be given out. This is enough to impersonate an individual. On top of this, since all data is stored in a single repository managed by the state or a corporation, it becomes particularly vulnerable to hacking or internal corruption. They narrow you down to one thing (in system or out, criminal or not, a credit score, etc.). The central database has little use for more information than this. This limits the functionality of the system and results in great injustices (for example convicted individuals find it hard to re-enter society as this is the only information about themselves they can reliably convey). They are artificial , in the sense that the information stored about you usually bears little relation to what you or your friends think of as your identity. To quote directly from the paper: Recently, new identity paradigms have tried to get around some of these elements. One approach, adopted by \"big data\" platforms like Facebook and Google, is to overcome thinness [narrowness] by storing enormous amounts of detailed information about each individual. we might call this \"panoptic identity\". However, such solutions have greatly exacerbated the other two problems, as they require extremely artificial compromises to intimacy through the global sharing of data with platforms that would not otherwise store it, creating exceptional potential security risks. Why do we need this vision now? Given the rising political polarization and the increasing amount of information -- about -- us collected, shared, and cross-correlated by governments and corporations, there's a real risk our information will be used against us in ways we cannot imagine. If history has taught us anything, it's that power belongs to those who control the information. Right now that power belongs to the gatekeepers of our identities: governments and corporations. In an increasingly uncertain world, there's a real risk that general fear, discontent and polarization will result in that power being abused. In such a world, a check on government and corporate power that goes beyond formal legal protections is essential. By putting the control of information back in our hands, decentralized identity systems provide a natural technological check on the ability of governments and corporations to abuse their power. How can the developing world benefit? In the developing world, decentralized identity systems have the potential to help bring millions of people out of poverty. To quote the words of Timothy Ruff : Most of us take for granted that we can prove things about ourselves, unaware that over a billion people cannot. Identity is a prerequisite to financial inclusion, and financial inclusion is a big part of solving poverty. What are some use cases? Liquid democracy Imagine if you could vote every two weeks to express your political sentiment regarding interest rates. Imagine if you could have a direct say in any decision, rather than relying on elected politicians to represent you. Imagine if those in power were held accountable in real-time, rather than once every few years. This is the promise of liquid democracy. Liquid democracy exists somewhere in the sweet spot between direct and representative democracy. As with direct democracy, everyone has the opportunity to vote on every issue. However, unlike direct democracy, you also have the choice to delegate your vote to someone else. You can even choose to delegate your votes on different issues to different people. For example, on environmental issues you might choose to delegate your vote to your favourite environmentalist. Whereas on issues concerning government debt and taxation you might choose your father. This ability to delegate is recursive. Meaning that if your father in turn chooses to delegate his vote on financial issues to his favourite economist, your vote will also be delegated to that economist. If you're unhappy with your father's decision, you can take that power away from him/her and either vote yourself or re-delegate to someone you deem more trustworthy. Under such a system, those with the most delegations become our representatives. Except unlike representative democracy, they are held accountable in real time. A system like this addresses the uninformed voter issue that a direct democracy creates by allowing voters to allot their votes to experts in their fields. It also addresses the corruption issues of a representative democracy because citizens can rescind their vote from someone instantly, forcing delegates to vote in the best interest of their constituents. It is the best of both worlds that truly gives the power of influence to the voters. Source This sounds almost too good to be true. A fair, transparent and corruption-free government\u2026 why haven't we implemented this before? Since there's no central government under this form of democracy, we need to figure out how to allow citizens to vote in a secure, private, and decentralized way. It turns out this is a pretty hard problem to solve. It's actually been impossible to solve. Until now. This is the first time in our history that the technology exists to turn this dream into a reality. Of course, we're talking about public blockchains. Right now we're very much still in the experimentation phase. There are still some hard challenges that need to be overcome. The three main ones revolve around scalability , privacy , and preventing Sybil attacks . Scalability is important because we need millions of people to be able to use these systems. Privacy is important because it ensures voters can't be discriminated against for the decisions they make. It also makes it harder for them to be bribed/coerced into voting for something they don't believe in. But perhaps the hardest challenge is to ensure one person is not able to vote multiple times (what's known in the jargon as a Sybil attack). The key to solving these last two is a voting protocol that requires some basic verification and reputation for each user while still protecting their pseudonymous identity. In other words a voting protocol with a built in decentralized identity system. Put another way, decentralized identity is the big unlock that's needed to turn liquid democracy into a reality. P.S. It turns out that solving the privacy problem helps solve the scalability problem, but we won't get into that here.","title":"More on decentralized identity"},{"location":"basics/more-on-identity/#more-on-decentralized-identity","text":"","title":"More on decentralized identity"},{"location":"basics/more-on-identity/#why-does-identity-matter","text":"In the words of Vitalik : Mechanisms that do not rely on identity cannot solve the problem of concentrated interests outcompeting dispersed communities; an identity-free mechanism that empowers distributed communities cannot avoid over-empowering centralized plutocrats pretending to be distributed communities. In other words, without an identity mechanism, one can't ensure one human one address, or one human one vote. This means that however you structure the rules of the system, those with the most resources will be able to game it.","title":"Why does identity matter?"},{"location":"basics/more-on-identity/#how-is-the-existing-system-failing-us","text":"In recent times, identities have been verified by credentials such as a passport or social network account issued by a central authority (usually a state or corporation). However, as noted in Verifying Identity as a Social Intersection , such identity systems have several interrelated flaws: They are insecure . Crucial data such as an ID number constantly has to be given out. This is enough to impersonate an individual. On top of this, since all data is stored in a single repository managed by the state or a corporation, it becomes particularly vulnerable to hacking or internal corruption. They narrow you down to one thing (in system or out, criminal or not, a credit score, etc.). The central database has little use for more information than this. This limits the functionality of the system and results in great injustices (for example convicted individuals find it hard to re-enter society as this is the only information about themselves they can reliably convey). They are artificial , in the sense that the information stored about you usually bears little relation to what you or your friends think of as your identity. To quote directly from the paper: Recently, new identity paradigms have tried to get around some of these elements. One approach, adopted by \"big data\" platforms like Facebook and Google, is to overcome thinness [narrowness] by storing enormous amounts of detailed information about each individual. we might call this \"panoptic identity\". However, such solutions have greatly exacerbated the other two problems, as they require extremely artificial compromises to intimacy through the global sharing of data with platforms that would not otherwise store it, creating exceptional potential security risks.","title":"How is the existing system failing us?"},{"location":"basics/more-on-identity/#why-do-we-need-this-vision-now","text":"Given the rising political polarization and the increasing amount of information -- about -- us collected, shared, and cross-correlated by governments and corporations, there's a real risk our information will be used against us in ways we cannot imagine. If history has taught us anything, it's that power belongs to those who control the information. Right now that power belongs to the gatekeepers of our identities: governments and corporations. In an increasingly uncertain world, there's a real risk that general fear, discontent and polarization will result in that power being abused. In such a world, a check on government and corporate power that goes beyond formal legal protections is essential. By putting the control of information back in our hands, decentralized identity systems provide a natural technological check on the ability of governments and corporations to abuse their power.","title":"Why do we need this vision now?"},{"location":"basics/more-on-identity/#how-can-the-developing-world-benefit","text":"In the developing world, decentralized identity systems have the potential to help bring millions of people out of poverty. To quote the words of Timothy Ruff : Most of us take for granted that we can prove things about ourselves, unaware that over a billion people cannot. Identity is a prerequisite to financial inclusion, and financial inclusion is a big part of solving poverty.","title":"How can the developing world benefit?"},{"location":"basics/more-on-identity/#what-are-some-use-cases","text":"","title":"What are some use cases?"},{"location":"basics/more-on-identity/#liquid-democracy","text":"Imagine if you could vote every two weeks to express your political sentiment regarding interest rates. Imagine if you could have a direct say in any decision, rather than relying on elected politicians to represent you. Imagine if those in power were held accountable in real-time, rather than once every few years. This is the promise of liquid democracy. Liquid democracy exists somewhere in the sweet spot between direct and representative democracy. As with direct democracy, everyone has the opportunity to vote on every issue. However, unlike direct democracy, you also have the choice to delegate your vote to someone else. You can even choose to delegate your votes on different issues to different people. For example, on environmental issues you might choose to delegate your vote to your favourite environmentalist. Whereas on issues concerning government debt and taxation you might choose your father. This ability to delegate is recursive. Meaning that if your father in turn chooses to delegate his vote on financial issues to his favourite economist, your vote will also be delegated to that economist. If you're unhappy with your father's decision, you can take that power away from him/her and either vote yourself or re-delegate to someone you deem more trustworthy. Under such a system, those with the most delegations become our representatives. Except unlike representative democracy, they are held accountable in real time. A system like this addresses the uninformed voter issue that a direct democracy creates by allowing voters to allot their votes to experts in their fields. It also addresses the corruption issues of a representative democracy because citizens can rescind their vote from someone instantly, forcing delegates to vote in the best interest of their constituents. It is the best of both worlds that truly gives the power of influence to the voters. Source This sounds almost too good to be true. A fair, transparent and corruption-free government\u2026 why haven't we implemented this before? Since there's no central government under this form of democracy, we need to figure out how to allow citizens to vote in a secure, private, and decentralized way. It turns out this is a pretty hard problem to solve. It's actually been impossible to solve. Until now. This is the first time in our history that the technology exists to turn this dream into a reality. Of course, we're talking about public blockchains. Right now we're very much still in the experimentation phase. There are still some hard challenges that need to be overcome. The three main ones revolve around scalability , privacy , and preventing Sybil attacks . Scalability is important because we need millions of people to be able to use these systems. Privacy is important because it ensures voters can't be discriminated against for the decisions they make. It also makes it harder for them to be bribed/coerced into voting for something they don't believe in. But perhaps the hardest challenge is to ensure one person is not able to vote multiple times (what's known in the jargon as a Sybil attack). The key to solving these last two is a voting protocol that requires some basic verification and reputation for each user while still protecting their pseudonymous identity. In other words a voting protocol with a built in decentralized identity system. Put another way, decentralized identity is the big unlock that's needed to turn liquid democracy into a reality. P.S. It turns out that solving the privacy problem helps solve the scalability problem, but we won't get into that here.","title":"Liquid democracy"},{"location":"circom-snarkjs/","text":"Circom 2.0 CIRCUIT COMPILER FOR ZK PROVING SYSTEMS Circom is a novel domain-specific language for defining arithmetic circuits and its associated compiler written in Rust language. Our open-source library of templates called CircomLib is publicly available to practitioners and developers. The library contains multiple circuit templates that have been reviewed and proven to work by our research team. The implementations of proving systems are also available in our libraries including SnarkJS , written in Javascript and Pure Web Assembly, wasmsnark written in native Web Assembly, rapidSnark written in C++ and Intel Assembly. Our team is currently working in the development of RapidPLONK and a run-time architecture for ARM processors. This way, Circom aims to provide developers a holistic framework to construct arithmetic circuits through an easy-to- use interface and abstract the complexity of the proving mechanisms. ==> circom","title":"Circom / snarkjs"},{"location":"circom-snarkjs/#circom-20","text":"CIRCUIT COMPILER FOR ZK PROVING SYSTEMS Circom is a novel domain-specific language for defining arithmetic circuits and its associated compiler written in Rust language. Our open-source library of templates called CircomLib is publicly available to practitioners and developers. The library contains multiple circuit templates that have been reviewed and proven to work by our research team. The implementations of proving systems are also available in our libraries including SnarkJS , written in Javascript and Pure Web Assembly, wasmsnark written in native Web Assembly, rapidSnark written in C++ and Intel Assembly. Our team is currently working in the development of RapidPLONK and a run-time architecture for ARM processors. This way, Circom aims to provide developers a holistic framework to construct arithmetic circuits through an easy-to- use interface and abstract the complexity of the proving mechanisms.","title":"Circom 2.0"},{"location":"circom-snarkjs/#circom","text":"","title":"==&gt; circom"},{"location":"guides/centralized-login/","text":"Centralized login use case Overview This document will guide you through the steps required to integrate iden3's technology into your application's login. Date 2019-04-05 Introduction Iden3 is a complete decentralized identity management solution that allows users to leverage their pre-existing validated identities to proof they are who they claim to be, saving them the hassle of having to individually register with each service that requires a validated identification. One of the direct applications of iden3's technology is to allow web services to reuse these identities for login into their portals. The diagram below shows the steps taken by your back-end to enable access to your application using iden3 identity system once the user requests to login. Iden3 provides the SDK to take care of requesting and verifying identity so that the user can be authenticated. Platforms supported JavaScript https://github.com/iden3/iden3js Go https://github.com/iden3/go-iden3 Pre-requirements Minimum requirements for a functional centralized login include: iden3 wallet service has been deployed User attempting to login has at least one valid identity. Integration A JavaScript reference implementation of how a third party can integrate iden3's solution to login into their application can be found at https://github.com/iden3/centralized-login-demo . In this example the external service includes a front-end and a back-end server. We will assume this front-end/back-end division during our integration overview. Front-End On the front-end side you will typically need to embed a button to start the login process, and a place to display a QR code that the user can scan to complete the authentication. After the button is pressed, the front-end makes a request to the back-end to start the identity authentication and waits for the response containing the QR code to be displayed and scanned by the user. In the provided reference implementation this is achieved by JavaScript function getLoginData() found in frontend/index.js. This code shows how to : Send a request for a new requestIdenAssert packet to the centralized application back-end Open a websocket between front-end and back-end Display QR code containing the requestIdenAssert packet to be signed by iden3's wallet Back-End Generating requests of identity assertion On the back-end side you will need to prepare a new API endpoint to handle the requestIdenAssert() petitions from the front-end. In the reference implementation we use GET/login by calling JavaScript function const signatureRequest = iden3.protocols.login.newRequestIdenAssert(nonceDB, origin, timeout); or Go function: requestIdenAssert := NewRequestIdenAssert(nonceDb, origin, timeout) where nonceDB: is a NonceDB object generated by calling an API function and stored in a RAM database origin: domain of the emitter of the request, for example 'myweb.com' timeout: timeout in seconds, for example 2 minutes ( 120 ). nonceDB is obtained by calling the following JavaScript function: const nonceDB = new iden3.protocols.NonceDB(); or Go function: ``` {.sourceCode .c nonceDb := core.NewNonceDb()} Once you have the *signatureRequest* object, you can return it back to the front-end so that it can be displayed. #### Verifying signedPacket On the back-end you will also need to prepare a new API endpoint to handle the responses from iden3 wallet containing the *signedPacket*. In the reference implementation we use *POST /login* to allow the walled to send the signed data. To perform the verification in the newly added endpoint you just need to call *iden3js* library: ``` {.sourceCode .javascript} const verified = iden3.protocols.login.verifySignedPacket(nonceDB, origin, signedPacket); or go-iden3 library: verified, err := signedPacketVerifier. VerifySignedPacketIdenAssert(signedPacket, nonceDB, origin) where nonceDB: is the NonceDB object generated earlier. origin: domain of the emitter of the request, for example 'myweb.com' signedPacket: signed packet sent by iden3's wallet. verified: is null if verification fails. SDK installation iden3js Installation npm install --save @iden3/iden3 Import const iden3 = require('iden3'); go-iden3 Installation go get github.com/iden3/go-iden3 Import import { \"github.com/iden3/go-iden3/services/signedpacketsrv\" }","title":"Centralized login"},{"location":"guides/centralized-login/#centralized-login-use-case","text":"Overview This document will guide you through the steps required to integrate iden3's technology into your application's login. Date 2019-04-05","title":"Centralized login use case"},{"location":"guides/centralized-login/#introduction","text":"Iden3 is a complete decentralized identity management solution that allows users to leverage their pre-existing validated identities to proof they are who they claim to be, saving them the hassle of having to individually register with each service that requires a validated identification. One of the direct applications of iden3's technology is to allow web services to reuse these identities for login into their portals. The diagram below shows the steps taken by your back-end to enable access to your application using iden3 identity system once the user requests to login. Iden3 provides the SDK to take care of requesting and verifying identity so that the user can be authenticated.","title":"Introduction"},{"location":"guides/centralized-login/#platforms-supported","text":"JavaScript https://github.com/iden3/iden3js Go https://github.com/iden3/go-iden3","title":"Platforms supported"},{"location":"guides/centralized-login/#pre-requirements","text":"Minimum requirements for a functional centralized login include: iden3 wallet service has been deployed User attempting to login has at least one valid identity.","title":"Pre-requirements"},{"location":"guides/centralized-login/#integration","text":"A JavaScript reference implementation of how a third party can integrate iden3's solution to login into their application can be found at https://github.com/iden3/centralized-login-demo . In this example the external service includes a front-end and a back-end server. We will assume this front-end/back-end division during our integration overview.","title":"Integration"},{"location":"guides/centralized-login/#front-end","text":"On the front-end side you will typically need to embed a button to start the login process, and a place to display a QR code that the user can scan to complete the authentication. After the button is pressed, the front-end makes a request to the back-end to start the identity authentication and waits for the response containing the QR code to be displayed and scanned by the user. In the provided reference implementation this is achieved by JavaScript function getLoginData() found in frontend/index.js. This code shows how to : Send a request for a new requestIdenAssert packet to the centralized application back-end Open a websocket between front-end and back-end Display QR code containing the requestIdenAssert packet to be signed by iden3's wallet","title":"Front-End"},{"location":"guides/centralized-login/#back-end","text":"","title":"Back-End"},{"location":"guides/centralized-login/#generating-requests-of-identity-assertion","text":"On the back-end side you will need to prepare a new API endpoint to handle the requestIdenAssert() petitions from the front-end. In the reference implementation we use GET/login by calling JavaScript function const signatureRequest = iden3.protocols.login.newRequestIdenAssert(nonceDB, origin, timeout); or Go function: requestIdenAssert := NewRequestIdenAssert(nonceDb, origin, timeout) where nonceDB: is a NonceDB object generated by calling an API function and stored in a RAM database origin: domain of the emitter of the request, for example 'myweb.com' timeout: timeout in seconds, for example 2 minutes ( 120 ). nonceDB is obtained by calling the following JavaScript function: const nonceDB = new iden3.protocols.NonceDB(); or Go function: ``` {.sourceCode .c nonceDb := core.NewNonceDb()} Once you have the *signatureRequest* object, you can return it back to the front-end so that it can be displayed. #### Verifying signedPacket On the back-end you will also need to prepare a new API endpoint to handle the responses from iden3 wallet containing the *signedPacket*. In the reference implementation we use *POST /login* to allow the walled to send the signed data. To perform the verification in the newly added endpoint you just need to call *iden3js* library: ``` {.sourceCode .javascript} const verified = iden3.protocols.login.verifySignedPacket(nonceDB, origin, signedPacket); or go-iden3 library: verified, err := signedPacketVerifier. VerifySignedPacketIdenAssert(signedPacket, nonceDB, origin) where nonceDB: is the NonceDB object generated earlier. origin: domain of the emitter of the request, for example 'myweb.com' signedPacket: signed packet sent by iden3's wallet. verified: is null if verification fails.","title":"Generating requests of identity assertion"},{"location":"guides/centralized-login/#sdk-installation","text":"","title":"SDK installation"},{"location":"guides/centralized-login/#iden3js","text":"","title":"iden3js"},{"location":"guides/centralized-login/#installation","text":"npm install --save @iden3/iden3","title":"Installation"},{"location":"guides/centralized-login/#import","text":"const iden3 = require('iden3');","title":"Import"},{"location":"guides/centralized-login/#go-iden3","text":"","title":"go-iden3"},{"location":"guides/centralized-login/#installation_1","text":"go get github.com/iden3/go-iden3","title":"Installation"},{"location":"guides/centralized-login/#import_1","text":"import { \"github.com/iden3/go-iden3/services/signedpacketsrv\" }","title":"Import"},{"location":"guides/circom-and-snarkjs/","text":"How to use circom and snarkjs Hello and welcome! In this guide we'll guide you through the creation of your first zero-knowledge snark circuit using circom and snarkjs . Circom is a library that allows you to build circuits to be used in zero knowledge proofs. While snarkjs is an independent implementation of the zk-snarks protocol -- fully written in JavaScript. Circom is designed to work with snarkjs. In other words, any circuit you build in circom can be used in snarkjs. We'll start by covering the various techniques to write circuits, then move on to creating and verifying a proof off-chain, and finish off by doing the same thing on-chain on Ethereum. If you have zero knowledge about zero-knowledge \ud83d\ude0b or are unsure about what a zk-snark is, we recommend you read this page first. To get started follow along from here .","title":"How to use circom and snarkjs"},{"location":"guides/circom-and-snarkjs/#how-to-use-circom-and-snarkjs","text":"Hello and welcome! In this guide we'll guide you through the creation of your first zero-knowledge snark circuit using circom and snarkjs . Circom is a library that allows you to build circuits to be used in zero knowledge proofs. While snarkjs is an independent implementation of the zk-snarks protocol -- fully written in JavaScript. Circom is designed to work with snarkjs. In other words, any circuit you build in circom can be used in snarkjs. We'll start by covering the various techniques to write circuits, then move on to creating and verifying a proof off-chain, and finish off by doing the same thing on-chain on Ethereum. If you have zero knowledge about zero-knowledge \ud83d\ude0b or are unsure about what a zk-snark is, we recommend you read this page first. To get started follow along from here .","title":"How to use circom and snarkjs"},{"location":"guides/introduction/","text":"Introduction","title":"Introduction"},{"location":"guides/introduction/#introduction","text":"","title":"Introduction"},{"location":"protocol/bjjkey/","text":"AuthBJJCredential AuthBJJCredential is primary credential for each identity. It represents authorization operational key. Hex of the current auth claim schema is ca938857241db9451ea329256b9c06e5 . This claim must be presented in the most circuits for identity verification. BabyJubjub key is using a specific elliptic curve defined over the large prime subgroup of BN128 elliptic curve. More about bjj key you can find here . X and Y values of bjj public key are part of Index data slots [I_3] and [I_4]. Below you can find an example of claim entry: Index: i_0: [ 128 bits] 269270088098491255471307608775043319525 // auth schema (big integer from ca938857241db9451ea329256b9c06e5) [ 32 bits ] 00010000000000000000 // header flags: first 000 - self claim 1 - expiration is set. [ 32 bits ] 0 [ 61 bits ] 0 i_1: [ 253 bits] 0 i_2: [ 253 bits] 15730379921066174438220083697399546667862601297001890929936158339406931652649 // x part of BJJ pubkey i_3: [ 253 bits] 5635420193976628435572861747946801377895543276711153351053385881432935772762 // y part of BJJ pubkey Value: v_0: [ 64 bits ] 2484496687 // revocation nonce [ 64 bits ] 1679670808 // expiration timestamp [ 125 bits] 0 v_1: [ 253 bits] 0 v_2: [ 253 bits] 0 v_3: [ 253 bits] 0","title":"AuthBJJCredential"},{"location":"protocol/bjjkey/#authbjjcredential","text":"AuthBJJCredential is primary credential for each identity. It represents authorization operational key. Hex of the current auth claim schema is ca938857241db9451ea329256b9c06e5 . This claim must be presented in the most circuits for identity verification. BabyJubjub key is using a specific elliptic curve defined over the large prime subgroup of BN128 elliptic curve. More about bjj key you can find here . X and Y values of bjj public key are part of Index data slots [I_3] and [I_4]. Below you can find an example of claim entry: Index: i_0: [ 128 bits] 269270088098491255471307608775043319525 // auth schema (big integer from ca938857241db9451ea329256b9c06e5) [ 32 bits ] 00010000000000000000 // header flags: first 000 - self claim 1 - expiration is set. [ 32 bits ] 0 [ 61 bits ] 0 i_1: [ 253 bits] 0 i_2: [ 253 bits] 15730379921066174438220083697399546667862601297001890929936158339406931652649 // x part of BJJ pubkey i_3: [ 253 bits] 5635420193976628435572861747946801377895543276711153351053385881432935772762 // y part of BJJ pubkey Value: v_0: [ 64 bits ] 2484496687 // revocation nonce [ 64 bits ] 1679670808 // expiration timestamp [ 125 bits] 0 v_1: [ 253 bits] 0 v_2: [ 253 bits] 0 v_3: [ 253 bits] 0","title":"AuthBJJCredential"},{"location":"protocol/circuits/","text":"Circuits Basic templates These are templates which are not used independently to create circuits but rather as building blocks for other templates. checkClaimExists The circuit checks that the claim exists in the sparse merkle tree. By \"exists\" we mean that a value Hv (hash of all values slots) is located by path Hi (hash of all index slots) in the tree. graph TB claim --> getClaimHiHv getClaimHiHv -- key --> SMTVerifier[SMTVerifier] getClaimHiHv -- value --> SMTVerifier claimMTP -- siblings --> SMTVerifier treeRoot -- root --> SMTVerifier 1 -- enabled --> SMTVerifier zero1[0] -- fnc --> SMTVerifier zero2[0] -- oldKey --> SMTVerifier zero3[0] -- oldValue --> SMTVerifier zero4[0] -- isOld0 --> SMTVerifier classDef inputStyle fill:#ecb3ff class claim,claimMTP,treeRoot inputStyle classDef circuitStyle fill:#b3ffd4,stroke-width:3px; class getClaimHiHv,SMTVerifier circuitStyle; checkClaimNonRev The circuit checks that the claim does not exist in the sparse merkle tree. That means that the tree leaf is empty by a path, which is defined by the claim nonce. graph TB claim --> getNonce getNonce -- key --> SMTVerifier[SMTVerifier entry does not exist] 0 -- value --> SMTVerifier claimMTP -- siblings --> SMTVerifier treeRoot -- root --> SMTVerifier 1 -- enabled --> SMTVerifier zero1[1] -- fnc --> SMTVerifier noAux -- isOld0 --> SMTVerifier auxHi -- oldKey --> SMTVerifier auxHv -- oldValue --> SMTVerifier classDef inputStyle fill:#ecb3ff class claim,claimMTP,treeRoot,noAux,auxHi,auxHv inputStyle classDef circuitStyle fill:#b3ffd4,stroke-width:3px; class getNonce,SMTVerifier circuitStyle; checkChallengeSignature The circuit checks that the challenge signature is correct. The public key for verification is extracted from the claim. graph TB claim --> getPubKeyFromClaim getPubKeyFromClaim -- Ax --> EdDSAPoseidonVerifier getPubKeyFromClaim -- Ay --> EdDSAPoseidonVerifier signatureS -- S --> EdDSAPoseidonVerifier signatureR8X -- R8X --> EdDSAPoseidonVerifier signatureR8Y -- R8Y --> EdDSAPoseidonVerifier challenge -- M --> EdDSAPoseidonVerifier classDef inputStyle fill:#ecb3ff class claim,getPubKey,signatureS,signatureR8Y,signatureR8X,challenge inputStyle classDef circuitStyle fill:#b3ffd4,stroke-width:3px class getPubKeyFromClaim,EdDSAPoseidonVerifier circuitStyle verifyIdenStateMatchesRoot The circuit calculate identity state from three merkle tree roots and checks if it is equal to expected state. graph TB claimsTreeRoot --> calcRoot revTreeRoot --> calcRoot rootsTreeRoot --> calcRoot calcRoot --> equal[=] expectedState ---> equal classDef inputStyle fill:#ecb3ff class claimsTreeRoot,revTreeRoot,rootsTreeRoot,expectedState inputStyle classDef circuitStyle fill:#b3ffd4,stroke-width:3px class calcRoot,equal circuitStyle query The circuit check that an expression with in, operator and value is true. For example in=\"1\", operator=\"4\", value=[\"5\",\"2\",\"3\"] is true because \"4\" is \"not in\" operator and \"1\" is not in the [\"5\",\"2\",\"3\"] array. See all the operators in the circuit comments. The circuit graph is not represented due to complexity. Functional templates These are the templates which Iden3 system uses directly to generate and verify proofs. A functional template may use basic of other functional templates as building blocks. The templates visualised as pivot tables. The columns of the tables are either basic templates or other functional templates. The rows represent inputs or group of inputs of the template. The cells are marked with \"+\" if relevant input and template are connected. See template docs example for idOwnershipBySignature The circuits check ownership of specific identity as follows: The claim with public key should exist in claims tree The claim with public key should not be revoked The signature of a challenge should be valid The state should equal to expected from blockchain The above enable verifier to check that some challenge is signed by identity which state is timestamped in blockchain and includes non revoked claim with relevant public key. check Claim Exists check Claim NonRevoked check Challenge Signature verify Iden State Matches Root claimsTreeRoot + + authClaimMTP + authClaim + + + revTreeRoot + + authClaimNonRevMTP + authClaimNonRevMtpNoAux + authClaimNonRevMtpAuxHi + authClaimNonRevMtpAuxHv + rootsTreeRoot + challenge + challengeSignatureS + challengeSignatureR8x + challengeSignatureR8y + hoIdenState + idOwnershipBySignature (graph experiment) graph LR subgraph ce [check claim exists] claimsTreeRoot --> checkClaimExists authClaimMTP --> checkClaimExists authClaim --> checkClaimExists end subgraph cnrev [check claim non revoked] authClaim --> checkClaimNonRevoked revTreeRoot --> checkClaimNonRevoked authClaimNonRevMTP --> checkClaimNonRevoked authClaimNonRevMtpNoAux --> checkClaimNonRevoked authClaimNonRevMtpAuxHi --> checkClaimNonRevoked authClaimNonRevMtpAuxHv --> checkClaimNonRevoked end subgraph cchals [check challenge signature] authClaim --> checkChallengeSignature challenge --> checkChallengeSignature challengeSignatureS --> checkChallengeSignature challengeSignatureR8x --> checkChallengeSignature challengeSignatureR8y --> checkChallengeSignature end subgraph vismr [verify iden state matches root] claimsTreeRoot --> verifyIdenStateMatchesRoot revTreeRoot --> verifyIdenStateMatchesRoot rootsTreeRoot --> verifyIdenStateMatchesRoot hoIdenState --> verifyIdenStateMatchesRoot end classDef inputStyle fill:#ecb3ff class claimsTreeRoot,authClaimMTP,authClaim,authClaim,revTreeRoot,authClaimNonRevMTP,authClaimNonRevMtpNoAux,authClaimNonRevMtpAuxHi,authClaimNonRevMtpAuxHv,challengeSignatureS,challengeSignatureR8x,challengeSignatureR8y,claimsTreeRoot,revTreeRoot,rootsTreeRoot inputStyle classDef publicInputStyle fill:#b3ffd4 class hoIdenState,challenge publicInputStyle classDef circuitStyle fill:#ffffff,stroke-width:3px class checkClaimNonRevoked,checkClaimExists,checkChallengeSignature,verifyIdenStateMatchesRoot circuitStyle CredentialAtomicQueryMTP The circuits check that an issuer have issued claim for identity and validates ownership of that identity as follows: Check identity ownership by idOwnershipBySignature template Check issuer claim exists in issuer claims tree Check issuer claim is not revoked by an issuer Check the issuer claim satisfies a query IdOwnership BySignature verify Credential Subject verify Credential Schema verify Expiration Time verify Claim Issuance NonRev Query id + (idOwnershipBySignature inputs) + claimSchema + claim + + + + + claimIssuanceMtp + claimIssuanceClaimsTreeRoot + claimIssuanceRevTreeRoot + claimIssuanceRootsTreeRoot + claimIssuanceIdenState + issuerID claimNonRevMtp + claimNonRevMtpNoAux + claimNonRevMtpAuxHi + claimNonRevMtpAuxHv + claimNonRevIssuerClaimsTreeRoot + claimNonRevIssuerRevTreeRoot + claimNonRevIssuerRootsTreeRoot + claimNonRevIssuerState + slotIndex + value + operator + timestamp + CredentialAtomicQuerySig [TBD] description... IdOwnership BySignature verify Credential Subject verify Credential Schema verify Expiration Time verify Issuer Auth Claim verify Claim Signature verify Iden State Matches Root verify Credential Not Revoked Query id + (idOwnershipBySignature inputs) + claimSchema + claim + + + + + claimSignatureR8x + claimSignatureR8y + claimSignatureS + issuerID issuerIdenState issuerClaimsTreeRoot + issuerRevTreeRoot issuerRootsTreeRoot issuerAuthClaimMtp + issuerAuthHi + issuerAuthHv + issuerPubKeyX + + issuerPubKeyY + + claimNonRevMtp + claimNonRevMtpNoAux + claimNonRevMtpAuxHi + claimNonRevMtpAuxHv + claimNonRevIssuerClaimsTreeRoot + claimNonRevIssuerRevTreeRoot + + claimNonRevIssuerRootsTreeRoot + claimNonRevIssuerState + slotIndex + value + operator + timestamp + Template docs example This is to understand what pivot tables of functional template mean. Let's say we have the following example template .circom template Example () { signal input input1; signal input input2; signal input input3; signal input input4; signal input input5; component template1 = Template1(); template1.in1 = input1; template1.in2 = input2; template1.in3 = input3; component template2 = Template2(); template2.in1 = input3; template2.in2 = input4; } So the graph for the template would be graph TB Input1 --> Template1 Input2 --> Template1 Input3 --> Template1 Input3 --> Template2 Input4 --> Template2 classDef inputStyle fill:#ecb3ff class Input1,Input2,Input3,Input4,Input5,Input6,Input7,Input8,Input9 inputStyle classDef circuitStyle fill:#b3ffd4,stroke-width:3px; class Template1,Template2,Template3 circuitStyle; and a pivot table Template1 Template2 Input1 + Input2 + Input3 + + Input4 +","title":"Circuits"},{"location":"protocol/circuits/#circuits","text":"","title":"Circuits"},{"location":"protocol/circuits/#basic-templates","text":"These are templates which are not used independently to create circuits but rather as building blocks for other templates.","title":"Basic templates"},{"location":"protocol/circuits/#checkclaimexists","text":"The circuit checks that the claim exists in the sparse merkle tree. By \"exists\" we mean that a value Hv (hash of all values slots) is located by path Hi (hash of all index slots) in the tree. graph TB claim --> getClaimHiHv getClaimHiHv -- key --> SMTVerifier[SMTVerifier] getClaimHiHv -- value --> SMTVerifier claimMTP -- siblings --> SMTVerifier treeRoot -- root --> SMTVerifier 1 -- enabled --> SMTVerifier zero1[0] -- fnc --> SMTVerifier zero2[0] -- oldKey --> SMTVerifier zero3[0] -- oldValue --> SMTVerifier zero4[0] -- isOld0 --> SMTVerifier classDef inputStyle fill:#ecb3ff class claim,claimMTP,treeRoot inputStyle classDef circuitStyle fill:#b3ffd4,stroke-width:3px; class getClaimHiHv,SMTVerifier circuitStyle;","title":"checkClaimExists"},{"location":"protocol/circuits/#checkclaimnonrev","text":"The circuit checks that the claim does not exist in the sparse merkle tree. That means that the tree leaf is empty by a path, which is defined by the claim nonce. graph TB claim --> getNonce getNonce -- key --> SMTVerifier[SMTVerifier entry does not exist] 0 -- value --> SMTVerifier claimMTP -- siblings --> SMTVerifier treeRoot -- root --> SMTVerifier 1 -- enabled --> SMTVerifier zero1[1] -- fnc --> SMTVerifier noAux -- isOld0 --> SMTVerifier auxHi -- oldKey --> SMTVerifier auxHv -- oldValue --> SMTVerifier classDef inputStyle fill:#ecb3ff class claim,claimMTP,treeRoot,noAux,auxHi,auxHv inputStyle classDef circuitStyle fill:#b3ffd4,stroke-width:3px; class getNonce,SMTVerifier circuitStyle;","title":"checkClaimNonRev"},{"location":"protocol/circuits/#checkchallengesignature","text":"The circuit checks that the challenge signature is correct. The public key for verification is extracted from the claim. graph TB claim --> getPubKeyFromClaim getPubKeyFromClaim -- Ax --> EdDSAPoseidonVerifier getPubKeyFromClaim -- Ay --> EdDSAPoseidonVerifier signatureS -- S --> EdDSAPoseidonVerifier signatureR8X -- R8X --> EdDSAPoseidonVerifier signatureR8Y -- R8Y --> EdDSAPoseidonVerifier challenge -- M --> EdDSAPoseidonVerifier classDef inputStyle fill:#ecb3ff class claim,getPubKey,signatureS,signatureR8Y,signatureR8X,challenge inputStyle classDef circuitStyle fill:#b3ffd4,stroke-width:3px class getPubKeyFromClaim,EdDSAPoseidonVerifier circuitStyle","title":"checkChallengeSignature"},{"location":"protocol/circuits/#verifyidenstatematchesroot","text":"The circuit calculate identity state from three merkle tree roots and checks if it is equal to expected state. graph TB claimsTreeRoot --> calcRoot revTreeRoot --> calcRoot rootsTreeRoot --> calcRoot calcRoot --> equal[=] expectedState ---> equal classDef inputStyle fill:#ecb3ff class claimsTreeRoot,revTreeRoot,rootsTreeRoot,expectedState inputStyle classDef circuitStyle fill:#b3ffd4,stroke-width:3px class calcRoot,equal circuitStyle","title":"verifyIdenStateMatchesRoot"},{"location":"protocol/circuits/#query","text":"The circuit check that an expression with in, operator and value is true. For example in=\"1\", operator=\"4\", value=[\"5\",\"2\",\"3\"] is true because \"4\" is \"not in\" operator and \"1\" is not in the [\"5\",\"2\",\"3\"] array. See all the operators in the circuit comments. The circuit graph is not represented due to complexity.","title":"query"},{"location":"protocol/circuits/#functional-templates","text":"These are the templates which Iden3 system uses directly to generate and verify proofs. A functional template may use basic of other functional templates as building blocks. The templates visualised as pivot tables. The columns of the tables are either basic templates or other functional templates. The rows represent inputs or group of inputs of the template. The cells are marked with \"+\" if relevant input and template are connected. See template docs example for","title":"Functional templates"},{"location":"protocol/circuits/#idownershipbysignature","text":"The circuits check ownership of specific identity as follows: The claim with public key should exist in claims tree The claim with public key should not be revoked The signature of a challenge should be valid The state should equal to expected from blockchain The above enable verifier to check that some challenge is signed by identity which state is timestamped in blockchain and includes non revoked claim with relevant public key. check Claim Exists check Claim NonRevoked check Challenge Signature verify Iden State Matches Root claimsTreeRoot + + authClaimMTP + authClaim + + + revTreeRoot + + authClaimNonRevMTP + authClaimNonRevMtpNoAux + authClaimNonRevMtpAuxHi + authClaimNonRevMtpAuxHv + rootsTreeRoot + challenge + challengeSignatureS + challengeSignatureR8x + challengeSignatureR8y + hoIdenState +","title":"idOwnershipBySignature"},{"location":"protocol/circuits/#idownershipbysignature-graph-experiment","text":"graph LR subgraph ce [check claim exists] claimsTreeRoot --> checkClaimExists authClaimMTP --> checkClaimExists authClaim --> checkClaimExists end subgraph cnrev [check claim non revoked] authClaim --> checkClaimNonRevoked revTreeRoot --> checkClaimNonRevoked authClaimNonRevMTP --> checkClaimNonRevoked authClaimNonRevMtpNoAux --> checkClaimNonRevoked authClaimNonRevMtpAuxHi --> checkClaimNonRevoked authClaimNonRevMtpAuxHv --> checkClaimNonRevoked end subgraph cchals [check challenge signature] authClaim --> checkChallengeSignature challenge --> checkChallengeSignature challengeSignatureS --> checkChallengeSignature challengeSignatureR8x --> checkChallengeSignature challengeSignatureR8y --> checkChallengeSignature end subgraph vismr [verify iden state matches root] claimsTreeRoot --> verifyIdenStateMatchesRoot revTreeRoot --> verifyIdenStateMatchesRoot rootsTreeRoot --> verifyIdenStateMatchesRoot hoIdenState --> verifyIdenStateMatchesRoot end classDef inputStyle fill:#ecb3ff class claimsTreeRoot,authClaimMTP,authClaim,authClaim,revTreeRoot,authClaimNonRevMTP,authClaimNonRevMtpNoAux,authClaimNonRevMtpAuxHi,authClaimNonRevMtpAuxHv,challengeSignatureS,challengeSignatureR8x,challengeSignatureR8y,claimsTreeRoot,revTreeRoot,rootsTreeRoot inputStyle classDef publicInputStyle fill:#b3ffd4 class hoIdenState,challenge publicInputStyle classDef circuitStyle fill:#ffffff,stroke-width:3px class checkClaimNonRevoked,checkClaimExists,checkChallengeSignature,verifyIdenStateMatchesRoot circuitStyle","title":"idOwnershipBySignature (graph experiment)"},{"location":"protocol/circuits/#credentialatomicquerymtp","text":"The circuits check that an issuer have issued claim for identity and validates ownership of that identity as follows: Check identity ownership by idOwnershipBySignature template Check issuer claim exists in issuer claims tree Check issuer claim is not revoked by an issuer Check the issuer claim satisfies a query IdOwnership BySignature verify Credential Subject verify Credential Schema verify Expiration Time verify Claim Issuance NonRev Query id + (idOwnershipBySignature inputs) + claimSchema + claim + + + + + claimIssuanceMtp + claimIssuanceClaimsTreeRoot + claimIssuanceRevTreeRoot + claimIssuanceRootsTreeRoot + claimIssuanceIdenState + issuerID claimNonRevMtp + claimNonRevMtpNoAux + claimNonRevMtpAuxHi + claimNonRevMtpAuxHv + claimNonRevIssuerClaimsTreeRoot + claimNonRevIssuerRevTreeRoot + claimNonRevIssuerRootsTreeRoot + claimNonRevIssuerState + slotIndex + value + operator + timestamp +","title":"CredentialAtomicQueryMTP"},{"location":"protocol/circuits/#credentialatomicquerysig","text":"[TBD] description... IdOwnership BySignature verify Credential Subject verify Credential Schema verify Expiration Time verify Issuer Auth Claim verify Claim Signature verify Iden State Matches Root verify Credential Not Revoked Query id + (idOwnershipBySignature inputs) + claimSchema + claim + + + + + claimSignatureR8x + claimSignatureR8y + claimSignatureS + issuerID issuerIdenState issuerClaimsTreeRoot + issuerRevTreeRoot issuerRootsTreeRoot issuerAuthClaimMtp + issuerAuthHi + issuerAuthHv + issuerPubKeyX + + issuerPubKeyY + + claimNonRevMtp + claimNonRevMtpNoAux + claimNonRevMtpAuxHi + claimNonRevMtpAuxHv + claimNonRevIssuerClaimsTreeRoot + claimNonRevIssuerRevTreeRoot + + claimNonRevIssuerRootsTreeRoot + claimNonRevIssuerState + slotIndex + value + operator + timestamp +","title":"CredentialAtomicQuerySig"},{"location":"protocol/circuits/#template-docs-example","text":"This is to understand what pivot tables of functional template mean. Let's say we have the following example template .circom template Example () { signal input input1; signal input input2; signal input input3; signal input input4; signal input input5; component template1 = Template1(); template1.in1 = input1; template1.in2 = input2; template1.in3 = input3; component template2 = Template2(); template2.in1 = input3; template2.in2 = input4; } So the graph for the template would be graph TB Input1 --> Template1 Input2 --> Template1 Input3 --> Template1 Input3 --> Template2 Input4 --> Template2 classDef inputStyle fill:#ecb3ff class Input1,Input2,Input3,Input4,Input5,Input6,Input7,Input8,Input9 inputStyle classDef circuitStyle fill:#b3ffd4,stroke-width:3px; class Template1,Template2,Template3 circuitStyle; and a pivot table Template1 Template2 Input1 + Input2 + Input3 + + Input4 +","title":"Template docs example"},{"location":"protocol/claims-structure/","text":"Claims data structure graph TD Hi-->i0 Hi-->i1 Hi-->i2 Hi-->i3 Hv-->v0 Hv-->v1 Hv-->v2 Hv-->v3 Ht-->Hi Ht-->Hv Common structure The claim always contains a subject: - Self : the claim says something about themself. The subject is implicit, and it's the claiming identity. - OtherIden : the claim says something about another identity by its ID. - Object : the claim says something about an object by its ID. If the subject is Self - identity sections i_1, v_1 can be empty. if the subject is NOT Self , the id(OtherIden) of the Identity/Object can be in the Index(i_1) or the Value(v_1) part of the Claim. This is encoded in a header bit. h_i = H(i_0, i_1, i_2, i_3) h_v = H(v_0, v_1, v_2, v_3) h_t = H(h_i, h_v) Index: i_0: [ 128 bits ] claim schema [ 32 bits ] header flags [3] Subject: 000: A.1 Self 001: invalid 010: A.2.i OtherIden Index 011: A.2.v OtherIden Value 100: B.i Object Index 101: B.v Object Value [1] Expiration: bool [1] Updatable: bool [27] 0 [ 32 bits ] version (optional?) [ 61 bits ] 0 - reserved for future use i_1: [ 248 bits] identity (case b) (optional) [ 5 bits ] 0 i_2: [ 253 bits] 0 i_3: [ 253 bits] 0 Value: v_0: [ 64 bits ] revocation nonce [ 64 bits ] expiration date (optional) [ 125 bits] 0 - reserved v_1: [ 248 bits] identity (case c) (optional) [ 5 bits ] 0 v_2: [ 253 bits] 0 v_3: [ 253 bits] 0 Claim shema - schemas define the kind of data inside a claim link Idex slots i_2 , i_3 and value slots v_2 , v_3 are data slots for user data Index VS Value When to use index slots and when value? Claims are stored in the Merkle tree and the hash of index slots ( hash(i_0,i_1,i_2,i_3) ) is unique for the whole tree. It means that you can not have two claims with the same index inside the tree. As opposite to index, values slots could be the same for different claims if their index is different.","title":"Structure"},{"location":"protocol/claims-structure/#claims-data-structure","text":"graph TD Hi-->i0 Hi-->i1 Hi-->i2 Hi-->i3 Hv-->v0 Hv-->v1 Hv-->v2 Hv-->v3 Ht-->Hi Ht-->Hv","title":"Claims data structure"},{"location":"protocol/claims-structure/#common-structure","text":"The claim always contains a subject: - Self : the claim says something about themself. The subject is implicit, and it's the claiming identity. - OtherIden : the claim says something about another identity by its ID. - Object : the claim says something about an object by its ID. If the subject is Self - identity sections i_1, v_1 can be empty. if the subject is NOT Self , the id(OtherIden) of the Identity/Object can be in the Index(i_1) or the Value(v_1) part of the Claim. This is encoded in a header bit. h_i = H(i_0, i_1, i_2, i_3) h_v = H(v_0, v_1, v_2, v_3) h_t = H(h_i, h_v) Index: i_0: [ 128 bits ] claim schema [ 32 bits ] header flags [3] Subject: 000: A.1 Self 001: invalid 010: A.2.i OtherIden Index 011: A.2.v OtherIden Value 100: B.i Object Index 101: B.v Object Value [1] Expiration: bool [1] Updatable: bool [27] 0 [ 32 bits ] version (optional?) [ 61 bits ] 0 - reserved for future use i_1: [ 248 bits] identity (case b) (optional) [ 5 bits ] 0 i_2: [ 253 bits] 0 i_3: [ 253 bits] 0 Value: v_0: [ 64 bits ] revocation nonce [ 64 bits ] expiration date (optional) [ 125 bits] 0 - reserved v_1: [ 248 bits] identity (case c) (optional) [ 5 bits ] 0 v_2: [ 253 bits] 0 v_3: [ 253 bits] 0 Claim shema - schemas define the kind of data inside a claim link Idex slots i_2 , i_3 and value slots v_2 , v_3 are data slots for user data","title":"Common structure"},{"location":"protocol/claims-structure/#index-vs-value","text":"When to use index slots and when value? Claims are stored in the Merkle tree and the hash of index slots ( hash(i_0,i_1,i_2,i_3) ) is unique for the whole tree. It means that you can not have two claims with the same index inside the tree. As opposite to index, values slots could be the same for different claims if their index is different.","title":"Index VS Value"},{"location":"protocol/querylanguage/","text":"Proof Query language Proof Query language specifications is still being built. Consider it work in progress. The goal of the query language Initial idea is to have a generic circuit with the possibility to do a verification based on user claims. As circuit setup is not a trivial task and especially the trusted setup is a challenging task to do for regular developers. We have to provide a simple generic query language based on generic prebuilt circuits. But query language should not be limited only in use by specific atomic circuits, but also utilized in other circuits. Syntax The first version planned to support only next operations : >, <, =, in and notin . Later on, this list could be extended Comparison operations > greater than < less than = equal to notin - matches none of the values in - matches one of the values we have to use some syntax instead of raw signs as it will be inconvenient to use signs <> = in JS. $eq as = , $gt as >,... more preferable way Simple operation { <field>: { $eq: <value> } } - equal { <field>: { $gt: <value> } } - greater then { <field>: { $lt: <value> } } - less then { <field>: { $nin: [<value>,<value>] } } { <field>: { $in: [<value>,<value>] } } For atomic claim these operations could cover a lot of use-cases. Atomic circuit The first implementation will cover only simple atomic verification of one field. It means we will do query requests only to one data field But also we have to do all required service verifications like check ownership, revocation, expiration, etc... We also have to include some additional attributes specific to the identity Schemas list List of trusted issuers Challenge Example: a simple query { \"circuit_id\": \"attrQuery\", \"type\": \"zkp\", \"rules\": { \"query\": [ { \"allowedIssuers\": [ \"115zTGHKvFeFLPu3vF9Wx2gBqnxGnzvTpmkHPM2LCe\" ], \"schema\": [ { \"url\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v2.json-ld\", \"type\": \"KYCAgeCredential\" } ], \"challenge\": 12345678, \"req\": { \"birthdate\": { \"$lt\": 20000101 } } } ] } } \ud83d\udca1 allowedIssuers \u2014 is a list of issuers to whom verifier trust schema \u2014 a list of schemas that claims can be used for proof generation challenge \u2014 used to verify that provided proof belongs to existing user session req \u2014 query request to circuit Example: multiple requests in one query (WIP) { \"circuit_id\": \"atomicQueryMTP\", \"type\": \"zkp\", \"rules\": { \"query\": [ { \"allowedIssuers\": [ \"115zTGHKvFeFLPu3vF9Wx2gBqnxGnzvTpmkHPM2LCe\" ], \"schema\": [ { \"url\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v2.json-ld\", \"type\": \"KYCAgeCredential\" } ], \"challenge\": 12345678, \"req\": { \"birthdate\": { \"$lt\": 20000101 } } }, { \"allowedIssuers\": [ \"115zTGHKvFeFLPu3vF9Wx2gBqnxGnzvTpmkHPM2LCe\" ], \"schema\": [ { \"type\": \"KYCCountryOfResidenceCredential\", \"url\": \"ipfs://QmP8NrKqoBKjmKwMsC8pwBCBxXR2PhwSepwXx31gnJxAbP\" } ], \"challenge\": 12345678, \"req\": { \"country\": { \"$nin\": [ 840, 123 ] } } } ] } } Query circuit should accept query requests and also have to do mandatory verification. Mandatory verification includes: Verify claim id ownership ( proof is generated by identity which is the subject of claim) Verify that claim is not revoked Verify that claim is not expired Verify that the identity key is not revoked Query: Apply query request Optional: Check schema Check issuer of the claim In some cases, schema and issuer could be not important. And in this case, we should leave the possibility to omit these fields List of signals for circuit Id ownership signal: signal input id; signal input hoIdenState; signal input hoClaimsTreeRoot; signal input authClaimMtp[IdOwnershipLevels]; signal input authClaim[8]; signal input hoRevTreeRoot; signal input authClaimNonRevMtp[IdOwnershipLevels]; signal input authClaimNonRevMtpNoAux; signal input authClaimNonRevMtpAuxHi; signal input authClaimNonRevMtpAuxHv; signal input hoRootsTreeRoot; signal input challenge; signal input challengeSignatureR8x; signal input challengeSignatureR8y; signal input challengeSignatureS; Claim signals: signal input claimSchema; signal input claim[8]; signal input claimIssuanceMtp[IssuerLevels]; signal input claimIssuanceClaimsTreeRoot; signal input claimIssuanceRevTreeRoot; signal input claimIssuanceRootsTreeRoot; signal input claimIssuanceIdenState; signal input issuerID; Verify claim revocation status: signal input claimNonRevMtp[IssuerLevels]; signal input claimNonRevMtpNoAux; signal input claimNonRevMtpAuxHi; signal input claimNonRevMtpAuxHv; signal input claimNonRevIssuerClaimsTreeRoot; signal input claimNonRevIssuerRevTreeRoot; signal input claimNonRevIssuerRootsTreeRoot; signal input claimNonRevIssuerState; Query request: signal input slotIndex; // index of field slot in the claim signal input value[valueArraySize]; // value for check signal input operator; // >,<, =,in, notin operations of CQL Public inputs: challenge, id, hoIdenState, issuerID, claimIssuanceIdenState, claimSchema, slotIndex, operator, value, timestamp Proof request workflow Verifier \u2192 User Verifier prepare proof request with a query to atomic circuit Request { \"circuit_id\": \"attrQuery\", \"type\": \"zkp\", \"rules\": { \"query\": [ { \"allowedIssuers\": [ \"115zTGHKvFeFLPu3vF9Wx2gBqnxGnzvTpmkHPM2LCe\" ], \"schema\": [ { \"url\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v2.json-ld\", \"type\": \"KYCAgeCredential\" } ], \"challenge\": 12345678, \"req\": { \"birthdate\": { \"$lt\": 20000101 } } } ] } } User parse a proof request and do necessary checks The circuit is known The schema is known Claims by the specified issuer persist in the wallet Get issuer public state for key non-revocation proof Prepare inputs for the circuit Prepare ownership / claim / issuer / query inputs Use schema to resolve field position in the claim Generate ZK proof Create proof sharing response protocol message and send it to the verifier Flow diagram Next steps Make it possible to query multiple fields from the same schema, but still limits to only 4 available slots, 2 indexes, and 2 values. With this combination, we can cover the more advanced use case Support more query operations Fields combinations Claim combinations Represents JSON-LD document as a tree and stores root as a claim. Extend verifications to this new schema. Do an atomic query verification Extended query schema with multifield verifications, from JSON-LD","title":"Proof Query language"},{"location":"protocol/querylanguage/#proof-query-language","text":"Proof Query language specifications is still being built. Consider it work in progress.","title":"Proof Query language"},{"location":"protocol/querylanguage/#the-goal-of-the-query-language","text":"Initial idea is to have a generic circuit with the possibility to do a verification based on user claims. As circuit setup is not a trivial task and especially the trusted setup is a challenging task to do for regular developers. We have to provide a simple generic query language based on generic prebuilt circuits. But query language should not be limited only in use by specific atomic circuits, but also utilized in other circuits.","title":"The goal of the query language"},{"location":"protocol/querylanguage/#syntax","text":"The first version planned to support only next operations : >, <, =, in and notin . Later on, this list could be extended Comparison operations > greater than < less than = equal to notin - matches none of the values in - matches one of the values we have to use some syntax instead of raw signs as it will be inconvenient to use signs <> = in JS. $eq as = , $gt as >,... more preferable way Simple operation { <field>: { $eq: <value> } } - equal { <field>: { $gt: <value> } } - greater then { <field>: { $lt: <value> } } - less then { <field>: { $nin: [<value>,<value>] } } { <field>: { $in: [<value>,<value>] } } For atomic claim these operations could cover a lot of use-cases.","title":"Syntax"},{"location":"protocol/querylanguage/#atomic-circuit","text":"The first implementation will cover only simple atomic verification of one field. It means we will do query requests only to one data field But also we have to do all required service verifications like check ownership, revocation, expiration, etc... We also have to include some additional attributes specific to the identity Schemas list List of trusted issuers Challenge Example: a simple query { \"circuit_id\": \"attrQuery\", \"type\": \"zkp\", \"rules\": { \"query\": [ { \"allowedIssuers\": [ \"115zTGHKvFeFLPu3vF9Wx2gBqnxGnzvTpmkHPM2LCe\" ], \"schema\": [ { \"url\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v2.json-ld\", \"type\": \"KYCAgeCredential\" } ], \"challenge\": 12345678, \"req\": { \"birthdate\": { \"$lt\": 20000101 } } } ] } } \ud83d\udca1 allowedIssuers \u2014 is a list of issuers to whom verifier trust schema \u2014 a list of schemas that claims can be used for proof generation challenge \u2014 used to verify that provided proof belongs to existing user session req \u2014 query request to circuit Example: multiple requests in one query (WIP) { \"circuit_id\": \"atomicQueryMTP\", \"type\": \"zkp\", \"rules\": { \"query\": [ { \"allowedIssuers\": [ \"115zTGHKvFeFLPu3vF9Wx2gBqnxGnzvTpmkHPM2LCe\" ], \"schema\": [ { \"url\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v2.json-ld\", \"type\": \"KYCAgeCredential\" } ], \"challenge\": 12345678, \"req\": { \"birthdate\": { \"$lt\": 20000101 } } }, { \"allowedIssuers\": [ \"115zTGHKvFeFLPu3vF9Wx2gBqnxGnzvTpmkHPM2LCe\" ], \"schema\": [ { \"type\": \"KYCCountryOfResidenceCredential\", \"url\": \"ipfs://QmP8NrKqoBKjmKwMsC8pwBCBxXR2PhwSepwXx31gnJxAbP\" } ], \"challenge\": 12345678, \"req\": { \"country\": { \"$nin\": [ 840, 123 ] } } } ] } } Query circuit should accept query requests and also have to do mandatory verification. Mandatory verification includes: Verify claim id ownership ( proof is generated by identity which is the subject of claim) Verify that claim is not revoked Verify that claim is not expired Verify that the identity key is not revoked Query: Apply query request Optional: Check schema Check issuer of the claim In some cases, schema and issuer could be not important. And in this case, we should leave the possibility to omit these fields List of signals for circuit Id ownership signal: signal input id; signal input hoIdenState; signal input hoClaimsTreeRoot; signal input authClaimMtp[IdOwnershipLevels]; signal input authClaim[8]; signal input hoRevTreeRoot; signal input authClaimNonRevMtp[IdOwnershipLevels]; signal input authClaimNonRevMtpNoAux; signal input authClaimNonRevMtpAuxHi; signal input authClaimNonRevMtpAuxHv; signal input hoRootsTreeRoot; signal input challenge; signal input challengeSignatureR8x; signal input challengeSignatureR8y; signal input challengeSignatureS; Claim signals: signal input claimSchema; signal input claim[8]; signal input claimIssuanceMtp[IssuerLevels]; signal input claimIssuanceClaimsTreeRoot; signal input claimIssuanceRevTreeRoot; signal input claimIssuanceRootsTreeRoot; signal input claimIssuanceIdenState; signal input issuerID; Verify claim revocation status: signal input claimNonRevMtp[IssuerLevels]; signal input claimNonRevMtpNoAux; signal input claimNonRevMtpAuxHi; signal input claimNonRevMtpAuxHv; signal input claimNonRevIssuerClaimsTreeRoot; signal input claimNonRevIssuerRevTreeRoot; signal input claimNonRevIssuerRootsTreeRoot; signal input claimNonRevIssuerState; Query request: signal input slotIndex; // index of field slot in the claim signal input value[valueArraySize]; // value for check signal input operator; // >,<, =,in, notin operations of CQL Public inputs: challenge, id, hoIdenState, issuerID, claimIssuanceIdenState, claimSchema, slotIndex, operator, value, timestamp","title":"Atomic circuit"},{"location":"protocol/querylanguage/#proof-request-workflow","text":"Verifier \u2192 User Verifier prepare proof request with a query to atomic circuit Request { \"circuit_id\": \"attrQuery\", \"type\": \"zkp\", \"rules\": { \"query\": [ { \"allowedIssuers\": [ \"115zTGHKvFeFLPu3vF9Wx2gBqnxGnzvTpmkHPM2LCe\" ], \"schema\": [ { \"url\": \"https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v2.json-ld\", \"type\": \"KYCAgeCredential\" } ], \"challenge\": 12345678, \"req\": { \"birthdate\": { \"$lt\": 20000101 } } } ] } } User parse a proof request and do necessary checks The circuit is known The schema is known Claims by the specified issuer persist in the wallet Get issuer public state for key non-revocation proof Prepare inputs for the circuit Prepare ownership / claim / issuer / query inputs Use schema to resolve field position in the claim Generate ZK proof Create proof sharing response protocol message and send it to the verifier Flow diagram","title":"Proof request workflow"},{"location":"protocol/querylanguage/#next-steps","text":"Make it possible to query multiple fields from the same schema, but still limits to only 4 available slots, 2 indexes, and 2 values. With this combination, we can cover the more advanced use case Support more query operations Fields combinations Claim combinations Represents JSON-LD document as a tree and stores root as a claim. Extend verifications to this new schema. Do an atomic query verification Extended query schema with multifield verifications, from JSON-LD","title":"Next steps"},{"location":"protocol/spec/","text":"Iden3 protocol specs (version 0) These specifications are still being built and updated regularly. Consider it work in progress. Basis Glossary Issuer: an actor who makes a claim. Holder: an actor who has received a claim. Verifier: an actor who verifies if the content of a claim is issued by a specific identity and held by another specific identity. Credential: data that is needed to prove that a claim is issued by a specific identity and held by another specific identity. This data is composed of a claim and a proof . MerkleTree A Merkle tree (MT) or hash tree is a cryptographically verifiable data structure where every \"leaf\" node of the tree contains the cryptographic hash of a data block, and every non-leaf node contains the cryptographic hash of its child nodes. The MTs used in the protocol has a few particularities: - Binary: each node can only have two children. - Sparse and Deterministic: the contained data is indexed, and each data block is placed at the leaf that corresponds to that data block's index, so insert order doesn't influence the final Merkle Tree Root. This also means that some nodes are empty. - ZK friendly: the used hash function, poseidon , plays well with the Zero-Knowledge proofs (ZKP) used in different parts of the protocol. In order to ensure that these particularities are respected and to have a history of all changes that occurred on different trees (without revealing the actual content stored in the leaves), the root of each MT is indirectly stored on the blockchain . EVM-based blockchains are chosen for this purpose. The Merkle Tree specification is defined in this document . In the future, the MT implementation could be changed. Zero-Knowledge proof (ZKP) In cryptography, a zero-knowledge proof is a method by which one party (the prover) can prove to another party (the verifier) that prover knows a value x that fulfills some constraints, without revealing any information apart from the fact that he/she knows the value x. The technologies that implement these methods are evolving rapidly. As of now, the protocol uses zkSNARKs Groth16, but in the future, the zk protocol could be changed. zkSNARK stands for \"Zero-Knowledge Succinct Non-Interactive Argument of Knowledge\", and have the following properties: Non-interactive: with a single message (credential) from the prover, the verifier can verify the proof. This is good because it allows sending proofs to a smart contract that can verify them immediately. Efficient verification: it's computationally efficient to verify proofs, both in terms of size and operations. This is good for the protocol because verification happens on the blockchain with its inherent costs. Heavy proof generation: generating a proof is computationally very expensive and can be time-consuming even with powerful hardware. Setup: a pre-existing setup between the prover and verifier is required for the construction of zkSNARKs. In order to ensure that the verifier can not cheat one has to be sure that the keys used for the setup were destroyed. There are protocols to ensure that, resulting in a \"trusted setup\". More technical information about zkSNARKs on this article by Vitalik Buterin. Claims Definition A claim is a statement made by one identity about another identity or itself. Each claim is composed of two parts: index and value part. Claims are stored in the leaves of an MT. The index is hashed and used to determine in which leaf position the value of the claim will be stored. A special transition validation functions can be used to restrict how leaves are stored in the MT, e.g. make the MT append-only, so that leaves can't be updated or deleted, just added. Properties It's impossible to generate a proof of a statement on behalf of an identity without its consent. Claims can be revoked. Claims can be updated by creating new versions. When a claim is revoked, no further versions can be made. Claims can be set to be updatable or not with a flag (See claim structure). graph LR revoked(Revoked claim) no-claim-->v0 v0-->v1 v1-.->vN vN-->vN1 vN1-->revoked no-claim(No claim) v0(Claim v0) v1(Claim v1) vN(Claim vN) vN1(Claim vN+1) Claims can be verified. This means that it's possible to demonstrate cryptographically that a given claim is: Issued by a specific identity. Not revoked. Is of the last version of that claim if it's updatable. There are two types of claims regarding destination Claims about self properties. Example: Operational Key, Ethereum Address, etc. Claims about another identity property (another) identity has a property: directional relation between an identity and a property (See claim structure: identity stored in hIndex, i_1) property is owned by (another) identity: directional relation between a property and an identity (See claim structure: identity stored in hValue, v_1) NOTE: Some of these properties are only guaranteed by a transition validation function (explained above in this document). Structure h_i = H(i_0, i_1, i_2, i_3) h_v = H(v_0, v_1, v_2, v_3) h_t = H(h_i, h_v) graph TD Hi-->i0 Hi-->i1 Hi-->i2 Hi-->i3 Hv-->v0 Hv-->v1 Hv-->v2 Hv-->v3 Ht-->Hi Ht-->Hv Index: i_0: [ 128 bits ] claim schema [ 32 bits ] header flags [3] Subject: 000: A.1 Self 001: invalid 010: A.2.i OtherIden Index 011: A.2.v OtherIden Value 100: B.i Object Index 101: B.v Object Value [1] Expiration: bool [1] Updatable: bool [27] 0 [ 32 bits ] version (optional?) [ 61 bits ] 0 - reserved for future use i_1: [ 248 bits] identity (case b) (optional) [ 5 bits ] 0 i_2: [ 253 bits] 0 i_3: [ 253 bits] 0 Value: v_0: [ 64 bits ] revocation nonce [ 64 bits ] expiration date (optional) [ 125 bits] 0 - reserved v_1: [ 248 bits] identity (case c) (optional) [ 5 bits ] 0 v_2: [ 253 bits] 0 v_3: [ 253 bits] 0 Reliability of a claim content The correctness of what is said in a claim is not verifiable by the protocol, since every identity is free to claim whatever they want. Since it's possible to know which identity issued each claim, the trust / reputation that the issuer has can affect its credibility. However, the protocol can guarantee exclusivity: there cannot be two claims with the same index. So it's impossible that an identity claims that a particular property (index part of the claim) is linked to two different identities (value part of the claim) at the same time. Keys Keys are cryptographic elements that can be used to sign data. In the protocol keys are used to authenticate certain interactions. These keys require the authorization of the identity who owns them to be used. This is done by adding a claim with a specific schema, linking the key(s) with the identity. This way each time that a key is used for signing, the identity can (and must) prove the ownership of that key and the fact that the key is not revoked. Types of keys Baby Jubjub: used for authentication. This type of key is designed to be efficient when working with zkSNARKs. The Baby Jubjub Elliptic Curve specification is defined in this document . Identity Definition An identity is characterized by the claims, that the identity has issued, and the claims, that the identity has received from other identities, in other words: an identity is built by what the identity has said, and what others have said about the identity. Each claim that identity issues can be cryptographically proved and verified, ensuring that the claim existed under identity at a certain timestamp. graph TD Root-->A Root-->B A-->C A-->D B-->E B-->F C-->G C-->H D-->I D-->J E-->K E-->L F-->M F-->N G[\"claim\"] H[\"claim\"] I[\"claim\"] J[\"claim\"] K[\"claim\"] L[\"claim\"] M[\"claim\"] N[\"claim\"] To accomplish this (and other properties covered in this document), identities are built by MerkleTrees , where the claims are placed as the leaves, and the Root is published (indirectly through identity state) in the blockchain. With this construction, the identities can issue, update and revoke claims. The protocol construction is designed to enable Zero-Knowledge features, which means for example that identities have the ability to prove with Zero-Knowledge the ownership of properties of claims in issued and received claims among other capabilities and verify that claim is not revoked. Genesis ID Description Each identity has a unique identifier that is determined by the initial identity state (hash of its MerkleTree roots), called Genesis ID , under which the initial claims are placed, that are the ones contained in the initial state of the identity. For the initial implementation of the protocol, the Genesis Claims Tree will contain at least a claim of authorization of the Operational key, that allows operating in the name of identity. While an identity doesn't add, update or revoke claims after the Genesis State, its identity state does not need to be published on the blockchain, and the Genesis Claims can be verified directly against the Genesis ID , as it is built by the Merkle Root that holds that claims. NOTE: The Genesis ID is calculated with the Identity State as a hash of Genesis Claims Tree Root, an empty Revocation Tree Root and an empty Roots Tree Root. Identifier format The Identifier of an identity is determined by the identity type and the Genesis Identity State , what we call the Genesis ID . This is built by creating a MerkleTree that holds the initial state claims, calculating its Root, hashing it together with an empty Revocation Tree Root and an empty Roots Tree Root. Then taking the first 27 bytes of the result and adding 2 bytes at the beginning to specify the identity type, and 2 bytes at the end for checksum. In sum, the identifier is a byte array of 31 bytes, encoded in base58. The identity type specifies the specs that the identity follows, such as the hash function used by the identity. In this way, when the hash function changes, the identifiers of the identities will change, allowing to identify of which type and protocol is one identity. Identifier structure: - ID (genesis): base58 [ type | genesis_state | checksum ] - type : 2 bytes specifying the type - genesis_state : first 27 bytes from the identity state (using the genesis claim merkle tree) - checksum : addition (with overflow) of all ID bytes Little Endian 16 bits ( [ type | genesis_state ] ) Identity state The identity states are published on the blockchain under the identity identifier, anchoring the state of the identity with the timestamp when it is published. In this way, the claims of the identity can be proved against the anchored identity state at a certain timestamp. To transition from a state to another one, identities follow the transition functions. The identity states can be published on the blockchain directly performing the transaction to publish the root, or indirectly using a Relay. The genesis state is the initial state of any identity, and does not need to be published in the blockchain, as the claims under it can be verified against the identity identifier itself (that contains that identity state). Identity state transition function The ITF (Identity state Transition Function) is verified each time that the State is updated in order to ensure that the identities follow the protocol when updating the state. Identity MerkleTree is a sparse binary tree, that only allows the addition of leaves (no edition nor deletion), and to add new claims, update through versions and revoke, needs to be done according to the ITF . To ensure this we use Zero-Knowledge proofs, in a way that when an identity is publishing a new state to the Smart Contract, also sends a zero-knowledge proof ( \u03c0 ) proving that the \u03d5 is satisfied following the ITF . In this way, all the identity states published on the blockchain are validated to be following the protocol. In the initial version of the implementation there will not be checks that trees are append-only in the Smart Contract due to the complex computation needed to generate zk-proofs of multiple claim additions, which is needed for scalability. The full circuit can be found here: https://github.com/iden3/circuits/blob/master/circuits/idState.circom Identity Ownership We prove the identity ownership inside a zkSNARK proof. This means that the user can generate a zk-proof that he/she knows a private key corresponding to operational key for authorization claim added to Claims Tree, without revealing the claim and its position. This is codified inside a circom circuit, which can be used in other circuits (such as the id state update circuit). The full circuit can be found here: https://github.com/iden3/circuits/blob/master/circuits/idOwnershipBySignature.circom Identity key rotation An identity can self-issue and revoke many private keys and corresponding claims of the type operational key authorization enabling key rotation in that way. To support verification of such claims identity state should be publicly available in the blockchain. An identity can publish the state to blockchain directly or via the Relay. Any private key, for which a corresponding claim exists in the identity claims tree and does not exist in the identity revocation tree, can be used to create a zero-knowledge proof of valid credentials. Such proof should pass verification by a verifier as it is able to check the latest identity state in the blockchain. In the same way, any valid and non-revoked identity private key can be used to create a valid zk_proof for identity state transition function. Note: An identity may lose some privacy as far as it needs to disclose its state to a verifier, which can track all the proofs of the same identity in that way. However, this can be mitigated if the identity state is published to the blockchain via the Relay. In this case, only the Relay state needs to be disclosed to a verifier. Identity Revocation When identity revokes all claims of the type operational key authorization , it is considered as revoked , because this identity can no longer create proofs. Interaction between Identity and Claims Identity State Update The Identity State Update is the procedure used to update information about what this Identity claims. This involves three different actions: - Add a Claim - Update Updatable Claim (by incrementing the version and changing the Claim value part) - Revoke a Claim Definitions IdS : Identity State ClT : Claims Tree ClR : Claims Tree Root ReT : Revocation Tree ReR : Revocation Tree Root RoT : Roots Tree RoR : Roots Tree Root The IdS (Identity State) is calculated concatenating the roots of the three user trees: - IdS : H(ClR || ReR || RoR) - Where H is the Hash function defined by the Identity Type (for example Poseidon) All trees are SMT (Sparse Merkle Tree) and use the hash function defined by the Identity Type. - Leaves in ClT (Claims Tree) are Claims ((4 + 4) * 253 bits = 253B) See Claims Structure Leaves in ReT (Revocation Tree) are Revocation Nonce + Version (64 + 32 bits = 12B) Revocation Tree Leaf: leaf: [ 64 bits ] revocation nonce [ 32 bits ] version [157 bits ] 0 Leaves in RoT (Roots Tree) are tree Roots (from the Claims Tree) (253 bits \u2248 32B) Roots Tree Leaf: leaf: [253 bits ] tree root Identity State Diagram for Direct Identity As seen in the diagram, only the IdS is stored in the Blockchain. In order to save stored bytes in the blockchain, it is desirable that only one \"hash\" representing the current state of the Identity is stored in the Smart Contract. This one \"hash\" is the IdS (Identity State), which is linked to a timestamp and a block in the blockchain. All the public data must be made available for any Holder so that they can build fresh merkle tree proofs of both the ReT and RoT . This allows the Holder to: Prove recent non-revocation / \"current\" version without interaction with the issuer. Hide a particular ClR from all the ClR s, to avoid allowing the issuer to discover a Claim hidden behind a ZK proof. For this purpose ClR added to RoR The place and method to access the publicly available data is specified in the Identities State Smart Contract. Two possible initial options are: IPFS, by adding a link to an IPNS address (example: ipfs://ipns/QmSrPmbaUKA3ZodhzPWZnpFgcPMFWF4QsxXbkWfEptTBJd ) which contains a standardized structure of the data. HTTPS, by adding a link to an HTTPS endpoint (example: https://kyc.iden3.io/api/v1/public-state/aabbccdd which offers the data following a standardized API. Publish Claims Publishing a Claim involves first adding a new leaf to the ClT , which updates the Identity ClR . Claims can be optionally published in batches, adding more than one leaf to the ClT in a single transaction. After the ClT has been updated, the Identity must follow an Identity State Update so that anyone is able to verify the newly added Claims. This involves adding the new ClR to the RoT which in turn will update the RoR . Afterwards, the new IdS is calculated and through a transaction it is updated in the Identities State Smart Contract (from now on, referred to as \"the Smart Contract\") in the blockchain. Once the updated IdS is in the Smart Contract, anyone can verify the validity of the newly added Claims. The updating procedure of the IdS in the Smart Contract can be achieved through the following means with the following properties: - Bad scalability (no batch), good privacy, correctness : The identity uploads the new IdS to the Smart Contract, with a proof of a correct transition from the old IdS to the new one. Only one claim is added to the ClT in the transition. - Good scalability (batch), good privacy, correctness : Same as before, but many claims are added (batch) in the transition (with a single proof for all newly added claims) - Good scalability (batch), good privacy, no correctness : The identity uploads the new IdS to the Smart Contract, without proving correctness on the transition. The correctness properties mentioned here are the following: - Revocation of a Claim can't be later undone - Updatable Claims are only updated with increasing versions, and only one version is valid at a time. The choice of having correctness guarantees or not is specified in the Identity Type, so that any Verifier knows about the guarantees provided by the protocol for the Issuer Claims. NOTE: Good scalability refers to the verification process and the costs related to the Smart Contract. Batching with zkSNARKs can have a high computation load to the prover. Revocation tree Sometimes it's desirable for an Identity to invalidate some statement made through a Claim. For regular Claims, this involves revoking, a process that's ideally irreversible, and allows any verifier to be aware that an already published Claim is made invalid by the Issuer Identity. Similarly, for updatable Claims, there must be a mechanism to invalidate old versions when a new one is published. Since confirming the current validity of a Claim is a parallel process to confirming that a Claim was published at some point, the \"current validation\" process can be separated. Separating these two processes allows a design in which the ClT (Claim Tree) remains private, but the revocation/version information is public, allowing a holder to generate a fresh proof of \"current validity\" without requesting access to the private ClT . To achieve this, every Identity has a ClT (Claim Tree) and a separate ReT (Revocation Tree). While the claim tree would be private and only the root public, the revocation tree would be entirely public. The roots of both trees ( ClT and ReT ) are linked via the IdS (Identity State) which is published in the Smart Contract. The revocation tree could be published in IPFS or any other public storage system. Proving that a claim is valid (and thus not revoked/updated) is separated into two proofs: 1. Prove that the claim was issued at some time T (this proof is generated once by the issuer and uses a IdS - ClR at time T stored in the Smart Contract) 2. Prove that the claim has not been revoked/updated recently (this proof is generated by the holder with a recent ReR (Revocation Tree Root) by querying the public ReT (Revocation Tree), and verified against a recent IdS ). Revoke Claims In order to not reveal anything about the content of the claim in the ReT , the Claim contains a revocation nonce in the value part, which is added as a leaf in the ReT to revocate the Claim. In order to forbid undoing revocation of a claim, the ReT needs to follow some transition rules like ClT , enforced by a ZK proof (for space and verification efficiency). Apart from the revoking procedure, there's a method to define the validity of a Claim based on expiration, by explicitly setting an expiration date in the Claim (See Claim Structure). Revoking and Expiration are compatible methods to invalidate Claims. Update Claims To update a Claim, first, a new Claim is added to the ClT with an increased version value in the index position in the claim (notice that the previous version of the claim is not touched). Then, a leaf is added to the ReT containing the revocation nonce and the maximum invalid version (that is, all Claims with that nonce and version equal or lower to the one in the leaf are invalid). This means that when a Claim is updated, the same revocation nonce is used in the Claim. In order to forbid downgrading the version of a Claim, and forcing to have only one valid updatable Claim at a time, the ReT needs to follow some transition rules like the ClT does, enforced by a ZK proof (for space and verification efficiency). Updating and Revoking are compatible methods to invalidate Claims: an updatable Claim can be revoked, meaning that no future (or past) updates will be valid. In case when a claim needs to be revoked completely, without possibility to update. The maximum version and the revocation nonce should be added to ReT Prove Claims (Credentials) Nomenclature - MTP: Merkle Tree Proof. The list of siblings in a path from a leaf to the root. Prove that a claim was issued at time at least t Requires proving a link between the Claim and an IdS_t (Identity State at time t) published in the Smart Contract. This proof requires: Claim t MTP Claim -> ClR_t RoR_t (Roots Tree at time t) ReR_t (Revocation Tree Root at time t) IdS_t Where t is any time. Prove that the claim is currently valid Prove that a claim hasn't been recently revoked Where t is a recent time. Requires proving the inexistence of a link between the Claim revocation nonce and a recent IdS_t ( t must be recent according to the verifier requirements [1]) published in the Smart Contract. This proof requires: Claim (Nonce) t MTP !Nonce -> ReR_t ClR_t RoR_t IdS_t [1] The verifier needs to decide a time span to define how recent the IdS_t used in the proof needs to be. Always requiring the current IdS could lead to data races, so it's better to require an IdS that is no more than X hours old. Proof of last version This is very similar to proving that a claim hasn't been recently revoked, except that not only the nonce in the claim is checked, but also the version. Requires proving the inexistence of a link between the Claim revocation nonce version and a recent IdS_t ( t must be recent according to the verifier requirements [1]) published in the Smart Contract. This proof requires: Claim (Nonce, Version) t MTP !(Nonce, Version) -> ReR_t ClR_t RoR_t IdS_t Where t is a recent time. Proof of non-Expiration A Claim can be expirable by setting the expiration flag in the options and specifying an expiration date in unix timestamp format in the corresponding claim value part (see Claim Format). Zero-Knowledge proof of valid Credential A Zero-Knowledge proof allows hiding some information about a Claim while proving that it was issued by a particular Identity and that it's currently valid. The same checks performed in the following sections are done: - Prove that a claim was issued at time at least t - Prove that the claim is currently valid In the proof that shows \"that a claim was issued at time at least t\" there's an additional part that is added to hide the particular IdS_t1 that is used (in order to hide the Claim from the Issuer, See Appendix Title 2). The proof then requires: - Claim - t - MTP Claim -> ClR_t1 - RoR_t1 (Roots Tree at time t1) - ReR_t1 (Revocation Tree Root at time t1) - IdS_t1 - MTP ClR_t1 -> RoR_t2 - ClR_t2 (Claims Tree Root at time t2) - ReR_t2 (Revocation Tree Root at time t2) - IdS_t2 Where t1 is a any time and t2 is a recent time. The full circuit can be found at: https://github.com/iden3/circuits/blob/master/circuits/credential.circom Identities Communications Issuer - Holder (Credential Request procedure) The same procedure works for already issued claims, and new claims: - The Issuer has issued a claim linking a property to the Holder, and the Holder requests the credential of the issued claim. - The Holder requests the issue of a new claim linking a property to the Holder. NOTE: In http, use polling to resolve the \"Future\". In async messaging, request the resolution of the \"Future\" and wait for the reply. Direct Claims sequenceDiagram Holder->>IssuerServer: req. Credential + auth? IssuerServer->>IssuerServer: Auto/Manual check IssuerServer->>IssuerServer: Add Claim to MT IssuerServer->>Holder: Future(Credential) IssuerServer->>SmartContract: Publish Root SmartContract->>IssuerServer: Ok Holder->>IssuerServer: Poll(Future(Credential)) IssuerServer->>Holder: Credential Indirect Claims sequenceDiagram Holder->>IssuerClient: req. Credential IssuerClient->>IssuerClient: Auto/Manual check IssuerClient->>IssuerClient: Add Claim to MT IssuerClient->>Relay: req. Credential (SetRoot) Relay->>Relay: Add Claim to MT Relay->>IssuerClient: Future(Credential1) IssuerClient->>Holder: Credential0, Future(Credential1) Relay->>SmartContract: Publish Root SmartContract->>Relay: Ok Holder->>Relay: Poll(Future(Credential1)) Relay->>Holder: Credential Holder - Verifier Verifier requests a claim (or in general, a proof that involves some claims). Holder shows a proof of the claim (or in general, a proof that involves some claims) to the Verifier. sequenceDiagram participant A Exchange_SC->>Exchange_SC: define CR with CRL A->>Exchange_SC: get CR Exchange_SC->>A: CR A->>A: build proof using Claim DB A->>Exchange_SC: proof Exchange_SC->>Exchange_SC: validate Exchange_SC->>Exchange_SC: action Exchange_SC->>A: result","title":"Iden3 protocol specs"},{"location":"protocol/spec/#iden3-protocol-specs-version-0","text":"These specifications are still being built and updated regularly. Consider it work in progress.","title":"Iden3 protocol specs (version 0)"},{"location":"protocol/spec/#basis","text":"","title":"Basis"},{"location":"protocol/spec/#glossary","text":"Issuer: an actor who makes a claim. Holder: an actor who has received a claim. Verifier: an actor who verifies if the content of a claim is issued by a specific identity and held by another specific identity. Credential: data that is needed to prove that a claim is issued by a specific identity and held by another specific identity. This data is composed of a claim and a proof .","title":"Glossary"},{"location":"protocol/spec/#merkletree","text":"A Merkle tree (MT) or hash tree is a cryptographically verifiable data structure where every \"leaf\" node of the tree contains the cryptographic hash of a data block, and every non-leaf node contains the cryptographic hash of its child nodes. The MTs used in the protocol has a few particularities: - Binary: each node can only have two children. - Sparse and Deterministic: the contained data is indexed, and each data block is placed at the leaf that corresponds to that data block's index, so insert order doesn't influence the final Merkle Tree Root. This also means that some nodes are empty. - ZK friendly: the used hash function, poseidon , plays well with the Zero-Knowledge proofs (ZKP) used in different parts of the protocol. In order to ensure that these particularities are respected and to have a history of all changes that occurred on different trees (without revealing the actual content stored in the leaves), the root of each MT is indirectly stored on the blockchain . EVM-based blockchains are chosen for this purpose. The Merkle Tree specification is defined in this document . In the future, the MT implementation could be changed.","title":"MerkleTree"},{"location":"protocol/spec/#zero-knowledge-proof-zkp","text":"In cryptography, a zero-knowledge proof is a method by which one party (the prover) can prove to another party (the verifier) that prover knows a value x that fulfills some constraints, without revealing any information apart from the fact that he/she knows the value x. The technologies that implement these methods are evolving rapidly. As of now, the protocol uses zkSNARKs Groth16, but in the future, the zk protocol could be changed. zkSNARK stands for \"Zero-Knowledge Succinct Non-Interactive Argument of Knowledge\", and have the following properties: Non-interactive: with a single message (credential) from the prover, the verifier can verify the proof. This is good because it allows sending proofs to a smart contract that can verify them immediately. Efficient verification: it's computationally efficient to verify proofs, both in terms of size and operations. This is good for the protocol because verification happens on the blockchain with its inherent costs. Heavy proof generation: generating a proof is computationally very expensive and can be time-consuming even with powerful hardware. Setup: a pre-existing setup between the prover and verifier is required for the construction of zkSNARKs. In order to ensure that the verifier can not cheat one has to be sure that the keys used for the setup were destroyed. There are protocols to ensure that, resulting in a \"trusted setup\". More technical information about zkSNARKs on this article by Vitalik Buterin.","title":"Zero-Knowledge proof (ZKP)"},{"location":"protocol/spec/#claims","text":"","title":"Claims"},{"location":"protocol/spec/#definition","text":"A claim is a statement made by one identity about another identity or itself. Each claim is composed of two parts: index and value part. Claims are stored in the leaves of an MT. The index is hashed and used to determine in which leaf position the value of the claim will be stored. A special transition validation functions can be used to restrict how leaves are stored in the MT, e.g. make the MT append-only, so that leaves can't be updated or deleted, just added.","title":"Definition"},{"location":"protocol/spec/#properties","text":"It's impossible to generate a proof of a statement on behalf of an identity without its consent. Claims can be revoked. Claims can be updated by creating new versions. When a claim is revoked, no further versions can be made. Claims can be set to be updatable or not with a flag (See claim structure). graph LR revoked(Revoked claim) no-claim-->v0 v0-->v1 v1-.->vN vN-->vN1 vN1-->revoked no-claim(No claim) v0(Claim v0) v1(Claim v1) vN(Claim vN) vN1(Claim vN+1) Claims can be verified. This means that it's possible to demonstrate cryptographically that a given claim is: Issued by a specific identity. Not revoked. Is of the last version of that claim if it's updatable. There are two types of claims regarding destination Claims about self properties. Example: Operational Key, Ethereum Address, etc. Claims about another identity property (another) identity has a property: directional relation between an identity and a property (See claim structure: identity stored in hIndex, i_1) property is owned by (another) identity: directional relation between a property and an identity (See claim structure: identity stored in hValue, v_1) NOTE: Some of these properties are only guaranteed by a transition validation function (explained above in this document).","title":"Properties"},{"location":"protocol/spec/#structure","text":"h_i = H(i_0, i_1, i_2, i_3) h_v = H(v_0, v_1, v_2, v_3) h_t = H(h_i, h_v) graph TD Hi-->i0 Hi-->i1 Hi-->i2 Hi-->i3 Hv-->v0 Hv-->v1 Hv-->v2 Hv-->v3 Ht-->Hi Ht-->Hv Index: i_0: [ 128 bits ] claim schema [ 32 bits ] header flags [3] Subject: 000: A.1 Self 001: invalid 010: A.2.i OtherIden Index 011: A.2.v OtherIden Value 100: B.i Object Index 101: B.v Object Value [1] Expiration: bool [1] Updatable: bool [27] 0 [ 32 bits ] version (optional?) [ 61 bits ] 0 - reserved for future use i_1: [ 248 bits] identity (case b) (optional) [ 5 bits ] 0 i_2: [ 253 bits] 0 i_3: [ 253 bits] 0 Value: v_0: [ 64 bits ] revocation nonce [ 64 bits ] expiration date (optional) [ 125 bits] 0 - reserved v_1: [ 248 bits] identity (case c) (optional) [ 5 bits ] 0 v_2: [ 253 bits] 0 v_3: [ 253 bits] 0","title":"Structure"},{"location":"protocol/spec/#reliability-of-a-claim-content","text":"The correctness of what is said in a claim is not verifiable by the protocol, since every identity is free to claim whatever they want. Since it's possible to know which identity issued each claim, the trust / reputation that the issuer has can affect its credibility. However, the protocol can guarantee exclusivity: there cannot be two claims with the same index. So it's impossible that an identity claims that a particular property (index part of the claim) is linked to two different identities (value part of the claim) at the same time.","title":"Reliability of a claim content"},{"location":"protocol/spec/#keys","text":"Keys are cryptographic elements that can be used to sign data. In the protocol keys are used to authenticate certain interactions. These keys require the authorization of the identity who owns them to be used. This is done by adding a claim with a specific schema, linking the key(s) with the identity. This way each time that a key is used for signing, the identity can (and must) prove the ownership of that key and the fact that the key is not revoked.","title":"Keys"},{"location":"protocol/spec/#types-of-keys","text":"Baby Jubjub: used for authentication. This type of key is designed to be efficient when working with zkSNARKs. The Baby Jubjub Elliptic Curve specification is defined in this document .","title":"Types of keys"},{"location":"protocol/spec/#identity","text":"","title":"Identity"},{"location":"protocol/spec/#definition_1","text":"An identity is characterized by the claims, that the identity has issued, and the claims, that the identity has received from other identities, in other words: an identity is built by what the identity has said, and what others have said about the identity. Each claim that identity issues can be cryptographically proved and verified, ensuring that the claim existed under identity at a certain timestamp. graph TD Root-->A Root-->B A-->C A-->D B-->E B-->F C-->G C-->H D-->I D-->J E-->K E-->L F-->M F-->N G[\"claim\"] H[\"claim\"] I[\"claim\"] J[\"claim\"] K[\"claim\"] L[\"claim\"] M[\"claim\"] N[\"claim\"] To accomplish this (and other properties covered in this document), identities are built by MerkleTrees , where the claims are placed as the leaves, and the Root is published (indirectly through identity state) in the blockchain. With this construction, the identities can issue, update and revoke claims. The protocol construction is designed to enable Zero-Knowledge features, which means for example that identities have the ability to prove with Zero-Knowledge the ownership of properties of claims in issued and received claims among other capabilities and verify that claim is not revoked.","title":"Definition"},{"location":"protocol/spec/#genesis-id","text":"","title":"Genesis ID"},{"location":"protocol/spec/#description","text":"Each identity has a unique identifier that is determined by the initial identity state (hash of its MerkleTree roots), called Genesis ID , under which the initial claims are placed, that are the ones contained in the initial state of the identity. For the initial implementation of the protocol, the Genesis Claims Tree will contain at least a claim of authorization of the Operational key, that allows operating in the name of identity. While an identity doesn't add, update or revoke claims after the Genesis State, its identity state does not need to be published on the blockchain, and the Genesis Claims can be verified directly against the Genesis ID , as it is built by the Merkle Root that holds that claims. NOTE: The Genesis ID is calculated with the Identity State as a hash of Genesis Claims Tree Root, an empty Revocation Tree Root and an empty Roots Tree Root.","title":"Description"},{"location":"protocol/spec/#identifier-format","text":"The Identifier of an identity is determined by the identity type and the Genesis Identity State , what we call the Genesis ID . This is built by creating a MerkleTree that holds the initial state claims, calculating its Root, hashing it together with an empty Revocation Tree Root and an empty Roots Tree Root. Then taking the first 27 bytes of the result and adding 2 bytes at the beginning to specify the identity type, and 2 bytes at the end for checksum. In sum, the identifier is a byte array of 31 bytes, encoded in base58. The identity type specifies the specs that the identity follows, such as the hash function used by the identity. In this way, when the hash function changes, the identifiers of the identities will change, allowing to identify of which type and protocol is one identity. Identifier structure: - ID (genesis): base58 [ type | genesis_state | checksum ] - type : 2 bytes specifying the type - genesis_state : first 27 bytes from the identity state (using the genesis claim merkle tree) - checksum : addition (with overflow) of all ID bytes Little Endian 16 bits ( [ type | genesis_state ] )","title":"Identifier format"},{"location":"protocol/spec/#identity-state","text":"The identity states are published on the blockchain under the identity identifier, anchoring the state of the identity with the timestamp when it is published. In this way, the claims of the identity can be proved against the anchored identity state at a certain timestamp. To transition from a state to another one, identities follow the transition functions. The identity states can be published on the blockchain directly performing the transaction to publish the root, or indirectly using a Relay. The genesis state is the initial state of any identity, and does not need to be published in the blockchain, as the claims under it can be verified against the identity identifier itself (that contains that identity state).","title":"Identity state"},{"location":"protocol/spec/#identity-state-transition-function","text":"The ITF (Identity state Transition Function) is verified each time that the State is updated in order to ensure that the identities follow the protocol when updating the state. Identity MerkleTree is a sparse binary tree, that only allows the addition of leaves (no edition nor deletion), and to add new claims, update through versions and revoke, needs to be done according to the ITF . To ensure this we use Zero-Knowledge proofs, in a way that when an identity is publishing a new state to the Smart Contract, also sends a zero-knowledge proof ( \u03c0 ) proving that the \u03d5 is satisfied following the ITF . In this way, all the identity states published on the blockchain are validated to be following the protocol. In the initial version of the implementation there will not be checks that trees are append-only in the Smart Contract due to the complex computation needed to generate zk-proofs of multiple claim additions, which is needed for scalability. The full circuit can be found here: https://github.com/iden3/circuits/blob/master/circuits/idState.circom","title":"Identity state transition function"},{"location":"protocol/spec/#identity-ownership","text":"We prove the identity ownership inside a zkSNARK proof. This means that the user can generate a zk-proof that he/she knows a private key corresponding to operational key for authorization claim added to Claims Tree, without revealing the claim and its position. This is codified inside a circom circuit, which can be used in other circuits (such as the id state update circuit). The full circuit can be found here: https://github.com/iden3/circuits/blob/master/circuits/idOwnershipBySignature.circom","title":"Identity Ownership"},{"location":"protocol/spec/#identity-key-rotation","text":"An identity can self-issue and revoke many private keys and corresponding claims of the type operational key authorization enabling key rotation in that way. To support verification of such claims identity state should be publicly available in the blockchain. An identity can publish the state to blockchain directly or via the Relay. Any private key, for which a corresponding claim exists in the identity claims tree and does not exist in the identity revocation tree, can be used to create a zero-knowledge proof of valid credentials. Such proof should pass verification by a verifier as it is able to check the latest identity state in the blockchain. In the same way, any valid and non-revoked identity private key can be used to create a valid zk_proof for identity state transition function. Note: An identity may lose some privacy as far as it needs to disclose its state to a verifier, which can track all the proofs of the same identity in that way. However, this can be mitigated if the identity state is published to the blockchain via the Relay. In this case, only the Relay state needs to be disclosed to a verifier.","title":"Identity key rotation"},{"location":"protocol/spec/#identity-revocation","text":"When identity revokes all claims of the type operational key authorization , it is considered as revoked , because this identity can no longer create proofs.","title":"Identity Revocation"},{"location":"protocol/spec/#interaction-between-identity-and-claims","text":"","title":"Interaction between Identity and Claims"},{"location":"protocol/spec/#identity-state-update","text":"The Identity State Update is the procedure used to update information about what this Identity claims. This involves three different actions: - Add a Claim - Update Updatable Claim (by incrementing the version and changing the Claim value part) - Revoke a Claim Definitions IdS : Identity State ClT : Claims Tree ClR : Claims Tree Root ReT : Revocation Tree ReR : Revocation Tree Root RoT : Roots Tree RoR : Roots Tree Root The IdS (Identity State) is calculated concatenating the roots of the three user trees: - IdS : H(ClR || ReR || RoR) - Where H is the Hash function defined by the Identity Type (for example Poseidon) All trees are SMT (Sparse Merkle Tree) and use the hash function defined by the Identity Type. - Leaves in ClT (Claims Tree) are Claims ((4 + 4) * 253 bits = 253B) See Claims Structure Leaves in ReT (Revocation Tree) are Revocation Nonce + Version (64 + 32 bits = 12B) Revocation Tree Leaf: leaf: [ 64 bits ] revocation nonce [ 32 bits ] version [157 bits ] 0 Leaves in RoT (Roots Tree) are tree Roots (from the Claims Tree) (253 bits \u2248 32B) Roots Tree Leaf: leaf: [253 bits ] tree root Identity State Diagram for Direct Identity As seen in the diagram, only the IdS is stored in the Blockchain. In order to save stored bytes in the blockchain, it is desirable that only one \"hash\" representing the current state of the Identity is stored in the Smart Contract. This one \"hash\" is the IdS (Identity State), which is linked to a timestamp and a block in the blockchain. All the public data must be made available for any Holder so that they can build fresh merkle tree proofs of both the ReT and RoT . This allows the Holder to: Prove recent non-revocation / \"current\" version without interaction with the issuer. Hide a particular ClR from all the ClR s, to avoid allowing the issuer to discover a Claim hidden behind a ZK proof. For this purpose ClR added to RoR The place and method to access the publicly available data is specified in the Identities State Smart Contract. Two possible initial options are: IPFS, by adding a link to an IPNS address (example: ipfs://ipns/QmSrPmbaUKA3ZodhzPWZnpFgcPMFWF4QsxXbkWfEptTBJd ) which contains a standardized structure of the data. HTTPS, by adding a link to an HTTPS endpoint (example: https://kyc.iden3.io/api/v1/public-state/aabbccdd which offers the data following a standardized API.","title":"Identity State Update"},{"location":"protocol/spec/#publish-claims","text":"Publishing a Claim involves first adding a new leaf to the ClT , which updates the Identity ClR . Claims can be optionally published in batches, adding more than one leaf to the ClT in a single transaction. After the ClT has been updated, the Identity must follow an Identity State Update so that anyone is able to verify the newly added Claims. This involves adding the new ClR to the RoT which in turn will update the RoR . Afterwards, the new IdS is calculated and through a transaction it is updated in the Identities State Smart Contract (from now on, referred to as \"the Smart Contract\") in the blockchain. Once the updated IdS is in the Smart Contract, anyone can verify the validity of the newly added Claims. The updating procedure of the IdS in the Smart Contract can be achieved through the following means with the following properties: - Bad scalability (no batch), good privacy, correctness : The identity uploads the new IdS to the Smart Contract, with a proof of a correct transition from the old IdS to the new one. Only one claim is added to the ClT in the transition. - Good scalability (batch), good privacy, correctness : Same as before, but many claims are added (batch) in the transition (with a single proof for all newly added claims) - Good scalability (batch), good privacy, no correctness : The identity uploads the new IdS to the Smart Contract, without proving correctness on the transition. The correctness properties mentioned here are the following: - Revocation of a Claim can't be later undone - Updatable Claims are only updated with increasing versions, and only one version is valid at a time. The choice of having correctness guarantees or not is specified in the Identity Type, so that any Verifier knows about the guarantees provided by the protocol for the Issuer Claims. NOTE: Good scalability refers to the verification process and the costs related to the Smart Contract. Batching with zkSNARKs can have a high computation load to the prover.","title":"Publish Claims"},{"location":"protocol/spec/#revocation-tree","text":"Sometimes it's desirable for an Identity to invalidate some statement made through a Claim. For regular Claims, this involves revoking, a process that's ideally irreversible, and allows any verifier to be aware that an already published Claim is made invalid by the Issuer Identity. Similarly, for updatable Claims, there must be a mechanism to invalidate old versions when a new one is published. Since confirming the current validity of a Claim is a parallel process to confirming that a Claim was published at some point, the \"current validation\" process can be separated. Separating these two processes allows a design in which the ClT (Claim Tree) remains private, but the revocation/version information is public, allowing a holder to generate a fresh proof of \"current validity\" without requesting access to the private ClT . To achieve this, every Identity has a ClT (Claim Tree) and a separate ReT (Revocation Tree). While the claim tree would be private and only the root public, the revocation tree would be entirely public. The roots of both trees ( ClT and ReT ) are linked via the IdS (Identity State) which is published in the Smart Contract. The revocation tree could be published in IPFS or any other public storage system. Proving that a claim is valid (and thus not revoked/updated) is separated into two proofs: 1. Prove that the claim was issued at some time T (this proof is generated once by the issuer and uses a IdS - ClR at time T stored in the Smart Contract) 2. Prove that the claim has not been revoked/updated recently (this proof is generated by the holder with a recent ReR (Revocation Tree Root) by querying the public ReT (Revocation Tree), and verified against a recent IdS ).","title":"Revocation tree"},{"location":"protocol/spec/#revoke-claims","text":"In order to not reveal anything about the content of the claim in the ReT , the Claim contains a revocation nonce in the value part, which is added as a leaf in the ReT to revocate the Claim. In order to forbid undoing revocation of a claim, the ReT needs to follow some transition rules like ClT , enforced by a ZK proof (for space and verification efficiency). Apart from the revoking procedure, there's a method to define the validity of a Claim based on expiration, by explicitly setting an expiration date in the Claim (See Claim Structure). Revoking and Expiration are compatible methods to invalidate Claims.","title":"Revoke Claims"},{"location":"protocol/spec/#update-claims","text":"To update a Claim, first, a new Claim is added to the ClT with an increased version value in the index position in the claim (notice that the previous version of the claim is not touched). Then, a leaf is added to the ReT containing the revocation nonce and the maximum invalid version (that is, all Claims with that nonce and version equal or lower to the one in the leaf are invalid). This means that when a Claim is updated, the same revocation nonce is used in the Claim. In order to forbid downgrading the version of a Claim, and forcing to have only one valid updatable Claim at a time, the ReT needs to follow some transition rules like the ClT does, enforced by a ZK proof (for space and verification efficiency). Updating and Revoking are compatible methods to invalidate Claims: an updatable Claim can be revoked, meaning that no future (or past) updates will be valid. In case when a claim needs to be revoked completely, without possibility to update. The maximum version and the revocation nonce should be added to ReT","title":"Update Claims"},{"location":"protocol/spec/#prove-claims-credentials","text":"Nomenclature - MTP: Merkle Tree Proof. The list of siblings in a path from a leaf to the root.","title":"Prove Claims (Credentials)"},{"location":"protocol/spec/#prove-that-a-claim-was-issued-at-time-at-least-t","text":"Requires proving a link between the Claim and an IdS_t (Identity State at time t) published in the Smart Contract. This proof requires: Claim t MTP Claim -> ClR_t RoR_t (Roots Tree at time t) ReR_t (Revocation Tree Root at time t) IdS_t Where t is any time.","title":"Prove that a claim was issued at time at least t"},{"location":"protocol/spec/#prove-that-the-claim-is-currently-valid","text":"","title":"Prove that the claim is currently valid"},{"location":"protocol/spec/#prove-that-a-claim-hasnt-been-recently-revoked","text":"Where t is a recent time. Requires proving the inexistence of a link between the Claim revocation nonce and a recent IdS_t ( t must be recent according to the verifier requirements [1]) published in the Smart Contract. This proof requires: Claim (Nonce) t MTP !Nonce -> ReR_t ClR_t RoR_t IdS_t [1] The verifier needs to decide a time span to define how recent the IdS_t used in the proof needs to be. Always requiring the current IdS could lead to data races, so it's better to require an IdS that is no more than X hours old.","title":"Prove that a claim hasn't been recently revoked"},{"location":"protocol/spec/#proof-of-last-version","text":"This is very similar to proving that a claim hasn't been recently revoked, except that not only the nonce in the claim is checked, but also the version. Requires proving the inexistence of a link between the Claim revocation nonce version and a recent IdS_t ( t must be recent according to the verifier requirements [1]) published in the Smart Contract. This proof requires: Claim (Nonce, Version) t MTP !(Nonce, Version) -> ReR_t ClR_t RoR_t IdS_t Where t is a recent time.","title":"Proof of last version"},{"location":"protocol/spec/#proof-of-non-expiration","text":"A Claim can be expirable by setting the expiration flag in the options and specifying an expiration date in unix timestamp format in the corresponding claim value part (see Claim Format).","title":"Proof of non-Expiration"},{"location":"protocol/spec/#zero-knowledge-proof-of-valid-credential","text":"A Zero-Knowledge proof allows hiding some information about a Claim while proving that it was issued by a particular Identity and that it's currently valid. The same checks performed in the following sections are done: - Prove that a claim was issued at time at least t - Prove that the claim is currently valid In the proof that shows \"that a claim was issued at time at least t\" there's an additional part that is added to hide the particular IdS_t1 that is used (in order to hide the Claim from the Issuer, See Appendix Title 2). The proof then requires: - Claim - t - MTP Claim -> ClR_t1 - RoR_t1 (Roots Tree at time t1) - ReR_t1 (Revocation Tree Root at time t1) - IdS_t1 - MTP ClR_t1 -> RoR_t2 - ClR_t2 (Claims Tree Root at time t2) - ReR_t2 (Revocation Tree Root at time t2) - IdS_t2 Where t1 is a any time and t2 is a recent time. The full circuit can be found at: https://github.com/iden3/circuits/blob/master/circuits/credential.circom","title":"Zero-Knowledge proof of valid Credential"},{"location":"protocol/spec/#identities-communications","text":"","title":"Identities Communications"},{"location":"protocol/spec/#issuer-holder-credential-request-procedure","text":"The same procedure works for already issued claims, and new claims: - The Issuer has issued a claim linking a property to the Holder, and the Holder requests the credential of the issued claim. - The Holder requests the issue of a new claim linking a property to the Holder. NOTE: In http, use polling to resolve the \"Future\". In async messaging, request the resolution of the \"Future\" and wait for the reply.","title":"Issuer - Holder (Credential Request procedure)"},{"location":"protocol/spec/#direct-claims","text":"sequenceDiagram Holder->>IssuerServer: req. Credential + auth? IssuerServer->>IssuerServer: Auto/Manual check IssuerServer->>IssuerServer: Add Claim to MT IssuerServer->>Holder: Future(Credential) IssuerServer->>SmartContract: Publish Root SmartContract->>IssuerServer: Ok Holder->>IssuerServer: Poll(Future(Credential)) IssuerServer->>Holder: Credential","title":"Direct Claims"},{"location":"protocol/spec/#indirect-claims","text":"sequenceDiagram Holder->>IssuerClient: req. Credential IssuerClient->>IssuerClient: Auto/Manual check IssuerClient->>IssuerClient: Add Claim to MT IssuerClient->>Relay: req. Credential (SetRoot) Relay->>Relay: Add Claim to MT Relay->>IssuerClient: Future(Credential1) IssuerClient->>Holder: Credential0, Future(Credential1) Relay->>SmartContract: Publish Root SmartContract->>Relay: Ok Holder->>Relay: Poll(Future(Credential1)) Relay->>Holder: Credential","title":"Indirect Claims"},{"location":"protocol/spec/#holder-verifier","text":"Verifier requests a claim (or in general, a proof that involves some claims). Holder shows a proof of the claim (or in general, a proof that involves some claims) to the Verifier. sequenceDiagram participant A Exchange_SC->>Exchange_SC: define CR with CRL A->>Exchange_SC: get CR Exchange_SC->>A: CR A->>A: build proof using Claim DB A->>Exchange_SC: proof Exchange_SC->>Exchange_SC: validate Exchange_SC->>Exchange_SC: action Exchange_SC->>A: result","title":"Holder - Verifier"},{"location":"protocol/zklogin/","text":"Server-side login (ZKP Login) Introduction Iden3 is SSI solution that allows users to leverage their pre-existing validated identities to prove they are who they claim to be based on zero-knowledge proofs. One of the direct applications of iden3\u2019s technology is to allow web applications to reuse these identities for login into their portals. Login workflow In a simple example application request a user identifier, which is done through zero-knowledge proof (zk proof) generation. The server generates an authentication request Auth request { \"type\": \"https://iden3-communication.io/authorization-request/v1\", \"data\": { \"callbackUrl\": \"https://test.com/callbackurl\", \"audience\": \"1125GJqgw6YEsKFwj63GY87MMxPL9kwDKxPUiwMLNZ\", \"scope\": [ { \"circuit_id\": \"auth\", \"type\": \"zeroknowledge\", \"rules\": { \"challenge\": 12345 } } ] } } This is an example of an authorization request. Scope field is a set of objects describes an array of proofs that must be generated on a user device and presented later. Each scope member has a unique definition of a circuit that must be used and rules (public inputs) that must be applied. This message can be delivered to user through different communication channels: QR code, email, deep-linking, .etc . On scan mobile has to implement: Parsing the auth request and understand which proof handler it should use Resolve verifier identifier if it\u2019s needed. Generate proofs using a specific handler. It can be signature proof or zero-knowledge Prepare an authentication response message. On mobile user generates ZK proof using auth circuit that will prove identity ownership, and send the response to the callback URL Auth response { \"type\": \"https://iden3-communication.io/authorization-response/v1\", \"data\": { \"scope\": [ { \"type\": \"zeroknowledge\", \"circuit_id\": \"auth\", \"pub_signals\": [ \"371135506535866236563870411357090963344408827476607986362864968105378316288\", \"12345\", \"16751774198505232045539489584666775489135471631443877047826295522719290880931\" ], \"proof_data\": { \"pi_a\": [ \"8286889681087188684411199510889276918687181609540093440568310458198317956303\", \"20120810686068956496055592376395897424117861934161580256832624025185006492545\", \"1\" ], \"pi_b\": [ [ \"8781021494687726640921078755116610543888920881180197598360798979078295904948\", \"19202155147447713148677957576892776380573753514701598304555554559013661311518\" ], [ \"15726655173394887666308034684678118482468533753607200826879522418086507576197\", \"16663572050292231627606042532825469225281493999513959929720171494729819874292\" ], [ \"1\", \"0\" ] ], \"pi_c\": [ \"9723779257940517259310236863517792034982122114581325631102251752415874164616\", \"3242951480985471018890459433562773969741463856458716743271162635077379852479\", \"1\" ], \"protocol\": \"groth16\" } } ] } } Client after receiving authorization response performs verification procedure: Zero-knowledge proof verification Extraction of metadata: (auth and circuit-specific) Verification of user identity states Verification of circuits public inputs (e.g. issuer state) Authentication based on zero-knowledge proof ZK proof is based on Circom 2.0 language. Auth circuit repository: https://github.com/iden3/circuits/blob/master/circuits/authentication.circom The circuit verifies that the user is the owner of the identity and his auth key is not revoked in the provided user state. Prerequisite Identity wallet installed Integration Back-end Generate auth request request := auth.CreateAuthorizationRequest(\"<challenge>\",\"<verifier identity|app-url>\", \"<callbackURI>\") // create auth request Validate auth request // unpack raw message message, err := packer.Unpack(msgBytes) // call library to verify zkp proofs err = auth.VerifyProofs(message) // extract metadata token, err := auth.ExtractMetadata(message) // verify state stateInfo, err := token.VerifyState(ctx.Background(),\"< rpc url >\", \"< state contract address >\") In future releases of auth library the verification procedure will be simplified and optimized for verifier. Front-end On the front-end side, you need to embed a button to start the login process. After the button is pressed, the front-end makes a request to the back-end to generate an authentication request and displays it in QR code. When the user scans the QR code, the phone generates ZK proof and sends the proof to the call-back URL from QR-code. Currently, we are working on js-iden3-auth library. Tutorial simple go app We need a simple web server with two endpoint GET /sign-in should return auth request POST /call-back endpoint to receive callback request from the phone and validate the request Let\u2019s write a simple web-server func main() { http.HandleFunc(\"/sign-in\", signIn) http.HandleFunc(\"/call-back\", callBack) http.ListenAndServe(\":8001\", nil) } func signIn(w http.ResponseWriter, req *http.Request) { } func callBack(w http.ResponseWriter, req *http.Request) { } Auth package Add authorization package to the project. go get https://github.com/iden3/go-iden3-auth Sign in To generate a ZK auth request we need a callback URL, to this URL we will receive a response from the mobile application with an authentication response. And verifier identity [do we really need this identity?] go-iden3-auth library contains a method for generating the authentication request [Descrition] func CreateAuthorizationRequest(challenge int64, aud, callbackURL string) *types.AuthorizationMessageRequest Now we are ready to generate auth request const CallBackUrl = \"http:localhost:8001/call-back\" const VerifierIdentity = \"1125GJqgw6YEsKFwj63GY87MMxPL9kwDKxPUiwMLNZ\" func signIn(w http.ResponseWriter, req *http.Request) { request := auth.CreateAuthorizationRequest(10, VerifierIdentity, callBackURI) msgBytes, _ := json.Marshal(request) // error handling ommited for simplification w.Header().Set(\"Content-Type\", \"application/json\") w.WriteHeader(http.StatusOK) w.Write(msgBytes) } Callback When we receive a callback request with ZK response we have to do a couple of things to validate this response Validate ZK proof, and make sure that the proof is valid Validate identity state on-chain, we are doing it to verify that user identity state is valid and his auth keys are not revoked First, let\u2019s validate ZK proof, for this we have a function func VerifyProofs(message types.Message) (err error) but before we can call it we need to unpack raw bytes to a message. Packer can be used to process encrypted message in future releases. p := &packer.PlainMessagePacker{} // Unpack msg message, _ := p.Unpack(msgBytes) // verify zkp proofErr := auth.VerifyProofs(message) Now ZK proof is verified and we can check identity status on chain Fist we need access to RPC URL, and address of identity smart-contract const rpc = \"https://polygon-mumbai.infura.io/v3/<your-token>\" const IdentityContract = \"0x3e95a7B12e8905E01126E1beA3F1a52D1624A725\" Before we can verify a state, we need to extract metadata, and then verify it on chain token, _:= auth.ExtractMetadata(message) // verify match identifier with the state on chain stateInfo, err := token.VerifyState(ctx, rpc, IdentityContract) Verification procedure details Zero-knowledge proof verification Groth16 proof are supported now by auth library Verification keys for circuits are known by the library itself. In the future, they can be resolved from circuits registries. Extraction of metadata Each circuit has a schema of its public inputs that links the public signal name to its position in the resulted array. This allows extracting user identifiers and challenges for authentication from proof. Other signals are added to the user token ( scope field) as attributes of a specific circuit. Circuit public signals schemas are known by this library or can be retrieved from some registry. Verification of user identity states The blockchain verification algorithm is used Get state from the blockchain (address of id state contract and URL must be provided by the caller of the library): Empty state is returned - it means that identity state hasn\u2019t been updated or updated state hasn\u2019t been published. We need to compare id and state. If they are different it\u2019s not a genesis state of identity then it\u2019s not valid. The non-empty state is returned and equals to the state in provided proof which means that the user state is fresh enough and we work with the latest user state. The non-empty state is returned and it\u2019s not equal to the state that the user has provided. Gets the time of the state transition. The verification party can make a decision if it can accept this state based on that time frame Verification party can make a decision to accept provided state or not. Verification of circuits public signals It can be different kind of verification e.g. 1. Check of that issuer states of provided claim proofs are published on the blockchain (same as for identity state) 2. Check of query signals, so claim schema and specific values can be verified. Full example Link to github === TODO: add proper link","title":"Login protocol"},{"location":"protocol/zklogin/#server-side-login-zkp-login","text":"","title":"Server-side login (ZKP Login)"},{"location":"protocol/zklogin/#introduction","text":"Iden3 is SSI solution that allows users to leverage their pre-existing validated identities to prove they are who they claim to be based on zero-knowledge proofs. One of the direct applications of iden3\u2019s technology is to allow web applications to reuse these identities for login into their portals. Login workflow In a simple example application request a user identifier, which is done through zero-knowledge proof (zk proof) generation. The server generates an authentication request Auth request { \"type\": \"https://iden3-communication.io/authorization-request/v1\", \"data\": { \"callbackUrl\": \"https://test.com/callbackurl\", \"audience\": \"1125GJqgw6YEsKFwj63GY87MMxPL9kwDKxPUiwMLNZ\", \"scope\": [ { \"circuit_id\": \"auth\", \"type\": \"zeroknowledge\", \"rules\": { \"challenge\": 12345 } } ] } } This is an example of an authorization request. Scope field is a set of objects describes an array of proofs that must be generated on a user device and presented later. Each scope member has a unique definition of a circuit that must be used and rules (public inputs) that must be applied. This message can be delivered to user through different communication channels: QR code, email, deep-linking, .etc . On scan mobile has to implement: Parsing the auth request and understand which proof handler it should use Resolve verifier identifier if it\u2019s needed. Generate proofs using a specific handler. It can be signature proof or zero-knowledge Prepare an authentication response message. On mobile user generates ZK proof using auth circuit that will prove identity ownership, and send the response to the callback URL Auth response { \"type\": \"https://iden3-communication.io/authorization-response/v1\", \"data\": { \"scope\": [ { \"type\": \"zeroknowledge\", \"circuit_id\": \"auth\", \"pub_signals\": [ \"371135506535866236563870411357090963344408827476607986362864968105378316288\", \"12345\", \"16751774198505232045539489584666775489135471631443877047826295522719290880931\" ], \"proof_data\": { \"pi_a\": [ \"8286889681087188684411199510889276918687181609540093440568310458198317956303\", \"20120810686068956496055592376395897424117861934161580256832624025185006492545\", \"1\" ], \"pi_b\": [ [ \"8781021494687726640921078755116610543888920881180197598360798979078295904948\", \"19202155147447713148677957576892776380573753514701598304555554559013661311518\" ], [ \"15726655173394887666308034684678118482468533753607200826879522418086507576197\", \"16663572050292231627606042532825469225281493999513959929720171494729819874292\" ], [ \"1\", \"0\" ] ], \"pi_c\": [ \"9723779257940517259310236863517792034982122114581325631102251752415874164616\", \"3242951480985471018890459433562773969741463856458716743271162635077379852479\", \"1\" ], \"protocol\": \"groth16\" } } ] } } Client after receiving authorization response performs verification procedure: Zero-knowledge proof verification Extraction of metadata: (auth and circuit-specific) Verification of user identity states Verification of circuits public inputs (e.g. issuer state)","title":"Introduction"},{"location":"protocol/zklogin/#authentication-based-on-zero-knowledge-proof","text":"ZK proof is based on Circom 2.0 language. Auth circuit repository: https://github.com/iden3/circuits/blob/master/circuits/authentication.circom The circuit verifies that the user is the owner of the identity and his auth key is not revoked in the provided user state.","title":"Authentication based on zero-knowledge proof"},{"location":"protocol/zklogin/#prerequisite","text":"Identity wallet installed","title":"Prerequisite"},{"location":"protocol/zklogin/#integration","text":"","title":"Integration"},{"location":"protocol/zklogin/#back-end","text":"Generate auth request request := auth.CreateAuthorizationRequest(\"<challenge>\",\"<verifier identity|app-url>\", \"<callbackURI>\") // create auth request Validate auth request // unpack raw message message, err := packer.Unpack(msgBytes) // call library to verify zkp proofs err = auth.VerifyProofs(message) // extract metadata token, err := auth.ExtractMetadata(message) // verify state stateInfo, err := token.VerifyState(ctx.Background(),\"< rpc url >\", \"< state contract address >\") In future releases of auth library the verification procedure will be simplified and optimized for verifier.","title":"Back-end"},{"location":"protocol/zklogin/#front-end","text":"On the front-end side, you need to embed a button to start the login process. After the button is pressed, the front-end makes a request to the back-end to generate an authentication request and displays it in QR code. When the user scans the QR code, the phone generates ZK proof and sends the proof to the call-back URL from QR-code. Currently, we are working on js-iden3-auth library.","title":"Front-end"},{"location":"protocol/zklogin/#tutorial-simple-go-app","text":"We need a simple web server with two endpoint GET /sign-in should return auth request POST /call-back endpoint to receive callback request from the phone and validate the request Let\u2019s write a simple web-server func main() { http.HandleFunc(\"/sign-in\", signIn) http.HandleFunc(\"/call-back\", callBack) http.ListenAndServe(\":8001\", nil) } func signIn(w http.ResponseWriter, req *http.Request) { } func callBack(w http.ResponseWriter, req *http.Request) { }","title":"Tutorial simple go app"},{"location":"protocol/zklogin/#auth-package","text":"Add authorization package to the project. go get https://github.com/iden3/go-iden3-auth","title":"Auth package"},{"location":"protocol/zklogin/#sign-in","text":"To generate a ZK auth request we need a callback URL, to this URL we will receive a response from the mobile application with an authentication response. And verifier identity [do we really need this identity?] go-iden3-auth library contains a method for generating the authentication request [Descrition] func CreateAuthorizationRequest(challenge int64, aud, callbackURL string) *types.AuthorizationMessageRequest Now we are ready to generate auth request const CallBackUrl = \"http:localhost:8001/call-back\" const VerifierIdentity = \"1125GJqgw6YEsKFwj63GY87MMxPL9kwDKxPUiwMLNZ\" func signIn(w http.ResponseWriter, req *http.Request) { request := auth.CreateAuthorizationRequest(10, VerifierIdentity, callBackURI) msgBytes, _ := json.Marshal(request) // error handling ommited for simplification w.Header().Set(\"Content-Type\", \"application/json\") w.WriteHeader(http.StatusOK) w.Write(msgBytes) }","title":"Sign in"},{"location":"protocol/zklogin/#callback","text":"When we receive a callback request with ZK response we have to do a couple of things to validate this response Validate ZK proof, and make sure that the proof is valid Validate identity state on-chain, we are doing it to verify that user identity state is valid and his auth keys are not revoked First, let\u2019s validate ZK proof, for this we have a function func VerifyProofs(message types.Message) (err error) but before we can call it we need to unpack raw bytes to a message. Packer can be used to process encrypted message in future releases. p := &packer.PlainMessagePacker{} // Unpack msg message, _ := p.Unpack(msgBytes) // verify zkp proofErr := auth.VerifyProofs(message) Now ZK proof is verified and we can check identity status on chain Fist we need access to RPC URL, and address of identity smart-contract const rpc = \"https://polygon-mumbai.infura.io/v3/<your-token>\" const IdentityContract = \"0x3e95a7B12e8905E01126E1beA3F1a52D1624A725\" Before we can verify a state, we need to extract metadata, and then verify it on chain token, _:= auth.ExtractMetadata(message) // verify match identifier with the state on chain stateInfo, err := token.VerifyState(ctx, rpc, IdentityContract)","title":"Callback"},{"location":"protocol/zklogin/#verification-procedure-details","text":"","title":"Verification procedure details"},{"location":"protocol/zklogin/#zero-knowledge-proof-verification","text":"Groth16 proof are supported now by auth library Verification keys for circuits are known by the library itself. In the future, they can be resolved from circuits registries.","title":"Zero-knowledge proof verification"},{"location":"protocol/zklogin/#extraction-of-metadata","text":"Each circuit has a schema of its public inputs that links the public signal name to its position in the resulted array. This allows extracting user identifiers and challenges for authentication from proof. Other signals are added to the user token ( scope field) as attributes of a specific circuit. Circuit public signals schemas are known by this library or can be retrieved from some registry.","title":"Extraction of metadata"},{"location":"protocol/zklogin/#verification-of-user-identity-states","text":"The blockchain verification algorithm is used Get state from the blockchain (address of id state contract and URL must be provided by the caller of the library): Empty state is returned - it means that identity state hasn\u2019t been updated or updated state hasn\u2019t been published. We need to compare id and state. If they are different it\u2019s not a genesis state of identity then it\u2019s not valid. The non-empty state is returned and equals to the state in provided proof which means that the user state is fresh enough and we work with the latest user state. The non-empty state is returned and it\u2019s not equal to the state that the user has provided. Gets the time of the state transition. The verification party can make a decision if it can accept this state based on that time frame Verification party can make a decision to accept provided state or not.","title":"Verification of user identity states"},{"location":"protocol/zklogin/#verification-of-circuits-public-signals","text":"It can be different kind of verification e.g. 1. Check of that issuer states of provided claim proofs are published on the blockchain (same as for identity state) 2. Check of query signals, so claim schema and specific values can be verified.","title":"Verification of circuits public signals"},{"location":"protocol/zklogin/#full-example","text":"Link to github === TODO: add proper link","title":"Full example"},{"location":"publications/publications/","text":"Publications Research Papers Baby Jubjub Elliptic Curve ( pdf ) EdDSA For Baby Jubjub Elliptic Curve with MiMC-7 Hash ( pdf ) 4-bit Window Pedersen Hash On The Baby Jubjub Elliptic Curve ( pdf ) Sparse Merkle Trees ( pdf ) Videos Intro to iden3 Circom and snarkjs Scalable distributed identity infrastructure using zero-knowledge proofs to guarantee privacy Websnarks - DappCon 2019 Big zkSnark circuits for zkRollups with circom - EthCC 2020 Slides Intro to iden3 Circom and snarkjs Scalabled distributed identity infrastructure using zero-knowledge proofs to guarantee privacy Big zkSnark circuits for zkRollups with circom - EthCC 2020","title":"Publications"},{"location":"publications/publications/#publications","text":"","title":"Publications"},{"location":"publications/publications/#research-papers","text":"Baby Jubjub Elliptic Curve ( pdf ) EdDSA For Baby Jubjub Elliptic Curve with MiMC-7 Hash ( pdf ) 4-bit Window Pedersen Hash On The Baby Jubjub Elliptic Curve ( pdf ) Sparse Merkle Trees ( pdf )","title":"Research Papers"},{"location":"publications/publications/#videos","text":"Intro to iden3 Circom and snarkjs Scalable distributed identity infrastructure using zero-knowledge proofs to guarantee privacy Websnarks - DappCon 2019 Big zkSnark circuits for zkRollups with circom - EthCC 2020","title":"Videos"},{"location":"publications/publications/#slides","text":"Intro to iden3 Circom and snarkjs Scalabled distributed identity infrastructure using zero-knowledge proofs to guarantee privacy Big zkSnark circuits for zkRollups with circom - EthCC 2020","title":"Slides"},{"location":"publications/pdfs/test/","text":"","title":"Test"},{"location":"services/libraries/","text":"Iden3 protocol libraries Crypto library ( go-iden3-crypto ) Implementation of Poseidon hash and Baby JubJub Eliptic curve Merkle tree sql library ( go-merkletree-sql ) Implementation of Sparse Merkle tree Core library ( go-iden3-core ) Identity core primitives Circuits ( circuits ) Identity circuits Go-circuits ( go-circuits ) Library for transformation go-core primitives to json inputs for identity circuits Prover server ( prover-server ) Wrapper on snarkjs for ZK proof generation Authorization library ( go-iden3-auth ) Library for authentication with zkp verification (edited)","title":"Libraries"},{"location":"services/libraries/#iden3-protocol-libraries","text":"Crypto library ( go-iden3-crypto ) Implementation of Poseidon hash and Baby JubJub Eliptic curve Merkle tree sql library ( go-merkletree-sql ) Implementation of Sparse Merkle tree Core library ( go-iden3-core ) Identity core primitives Circuits ( circuits ) Identity circuits Go-circuits ( go-circuits ) Library for transformation go-core primitives to json inputs for identity circuits Prover server ( prover-server ) Wrapper on snarkjs for ZK proof generation Authorization library ( go-iden3-auth ) Library for authentication with zkp verification (edited)","title":"Iden3 protocol libraries"},{"location":"services/login-protocol/","text":"Login Protocol Login protocol The login protocol is based on the signature protocol, in which a user signs a packet using an authorized kSign key. For the login case, the user desires to assert a particular identity (an ethereum address in this case) to a server so that they are allowed access into the service while being identified. Assumptions Secure connection between Wallet and Server. Secure connection between Web Client and Server. Wallet authenticates the Server in the connection. Web Client authenticates the Server in the connection. What is needed Server authenticates the Ethereum Address and Ethereum Name from the Wallet. The user transfers the authentication from the Wallet to the Web Client. Protocol flow Challenges contain a cryptographic nonce and have a timeout that indicates the validity of the nonce in the challenge. A signed challenge with a timed out nonce must be rejected by the server. The server must store a list of not timed out nonces that haven\u2019t been signed yet to guarantee freshness. A cryptographic nonce must be securely generated and long enough to avoid colisions (we use 256 bits). Signature Protocol v0.1 spec A signature may be requested as follows: { header: { typ: iden3.sig.v0_1 } body: { type: TYPE data: DATA } } The user will generate a packet following the signature protocol specification, that may contain data from a signature request, or may be made from scratch. The packet contains a header and a payload, and is serialized and signed following the JWS standard . Usually the form will be filled by the user, and data will be copied from a request. The structure of the data and form in the payload are specified by the type (what is being signed) in the payload. The rest of the elements are specified by the typ (signature packet) in the header. JWS_PAYLOAD = { type: TYPE data: DATA form: FORM ksign: str # ksing public key in compressed form proofKSing: proofClaim # Proof of authorize k sign claim (which contains the public key in compressed form) } JWS_HEADER = { typ: iden3.sig.v0_1 iss: str # Ethereum Address iat: uint # issued at time, unix timestamp exp: uint # expiration time, unix timestamp alg: ? # algorithm } JWS_SIGN(JWS_HEADER, JWS_PAYLOAD) Each Signature request type has a view representation for the user, where the data and form are presented. Some of the values may be hidden from the user when necessary, but only if doing so doesn\u2019t compromise the security of the user. In the request view, the user has the ability to pick some elements of the form . ksign is the compressed public key of a secp256k ECDSA key pair. The proofKSing contains a KSign Authorize Claim for a secp256k public key. As JWS_HEADER.alg we will use a custom algorithm (not defined in the JWS standard): \u201cEK256K1\u201d, which is ECDSA with secp256k1 curve and keccak as hash function, the same signature algorithm configuration used in Ethereum. Auxiliary data structures proofClaim: { signature: signature # Relay root + date signed by relay date: uint leaf: claim proofs: proofClaimPartial[] } proofClaimPartial: { mtp0: mtp # merkle tree proof of leaf existence mtp1: mtp # merkle tree proof of leaf non-existence root: key # merkle tree root aux: nil | { ver: uint, era: uint, idAddr: str } # Necessary data to construct SetRootClaim from root } Usually the relay returns the proofClaim data structure to prove that a claim is valid and is in the merkle tree. Identity Assertion v0.1 spec payload: type: iden3.iden_assert.v0_1 data: { challenge: nonce # 256 bits in base64 timeout: uint # seconds origin: str # domain } form: { ethName: str # ethereumName proofAssignName: proofClaim # proof of claim Assign Name for ethName } A session id, if necessary, can be computed from the challenge. This session id can be used to link the communication between the web service and the wallet service. view: type: Identity Assertion data: { origin: str # domain } form: { ethName: str # ethereum name } Algorithms Here we show an overview of the algorithms steps used for verification of the proofs and signatures used in the login protocol. The following algorithms consider the case in which there is a only a single trusted entity (identified by relayPk ) that acts as a relay and as a domain name server. Signature verification algorithm VerifySignedPacket(jwsHeader, jwsPayload, signature, relayPk): 1. Verify jwsHeader.typ is 'iden3.sig.v0_1' 2. Verify jwsHeader.alg is 'EK256K1' 3. Verify that jwsHeader.iat <= now() < jwsHeader.exp 4. Verify that jwsPayload.ksign is in jwsPayload.proofKSign.leaf 5. Verify that jwsHeader.iss is in jwsPayload.proofKSign 6. Verify that signature of JWS(jwsHeader, jwsPayload) by jwsPayload.ksign is signature 7. VerifyProofOfClaim(jwsPayload.proofKSign, relayPk) In 4. we verify that the ksign used to sign the packet is authorized by the user, identified by jwsHeader.iss ethereum address. Iden Assert verification algorithm VerifyIdenAssertV01(nonceDB, origin, jwsHeader, jwsPayload, signature, relayPk): 1. Verify jwsPayload.type is 'iden3.iden_assert.v0_1' 2. Verify jwsPayload.data.origin is origin 3. Verify jwsPayload.data.challenge is in nonceDB and hasn't expired, delete it 4. Verify that jwsHeader.iss and jwsPayload.form.ethName are in jwsPayload.proofAssignName.leaf 5. VerifyProofOfClaim(jwsPayload.form.ethName, relayPk) ProofOfClaim verification VerifyProofOfClaim(p, relayPk): 1. Verify signature of p.proofs[-1].root by relayPk is p.signature let leaf = p.leaf 2. loop for each proof in p.proofs: 2.1 Verify proof.mtp0 is existence proof 2.2 Verify proof.mtp0 with leaf and proof.root 2.3 Verify proof.mtp1 is non-existence proof 2.4 Verify proof.mtp1 with ClaimIncrementVersion(leaf) and proof.root leaf = NewClaimSetRootClaim(p.root, p.aux.ver, p.aux.era, p.aux.ethAddr) iden3js - protocols Login (Identity Assertion) Wallet Service + + | signatureRequest | | <-------------------------------------+ | | | | +---+ | | | | | |sign packet | | | | | <---+ | | signedPacket | | +-------------------------------------> | | | | +---+ | | verify | | | signedPacket| | | | | | +---> | | | | ok | | <-------------------------------------+ | | | | | | | + + Read the login protocol specification here . Define new NonceDB const nonceDB = new iden3.protocols.NonceDB(); Generate New Request of Identity Assert input nonceDB : NonceDB class object origin : domain of the emitter of the request timeout : unixtime format, valid until that date. We can use for example 2 minutes ( 2*60 seconds) output signatureRequest : Object {.sourceCode .js} const signatureRequest = iden3.protocols.login.newRequestIdenAssert(nonceDB, origin, 2*60); The nonce of the signatureRequest can be getted from: const nonce = signatureRequest.body.data.challenge; // nonce is the string containing the nonce value We can add auxiliar data to the nonce in the nonceDB only one time: const added = nodeDB.addAuxToNonce(nonce, auxdata); // added is a bool confirming if the aux data had been added Sign Packet input signatureRequest : object generated in the newRequestIdenAssert function userAddr : Eth Address of the user that signs the data packet ethName : name assigned to the userAddr proofOfEthName : proofOfClaim of the ethName kc : iden3.KeyContainer object ksign : KOperational authorized for the userAddr proofOfKSign : proofOfClaim of the ksign expirationTime : unixtime format, signature will be valid until that date output signedPacket : String {.sourceCode .js} const expirationTime = unixtime + (3600 * 60); const signedPacket = iden3.protocols.login.signIdenAssertV01(signatureRequest, usrAddr, ethName, proofOfEthName, kc, ksign, proofOfKSign, expirationTime); Verify Signed Packet input nonceDB : NonceDB class object origin : domain of the emitter of the request signedPacket : object generated in the signIdenAssertV01 function output nonce : nonce object of the signedPacket, that has been just deleted from the nonceDB when the signedPacket is verified. If the verification fails, the nonce will be undefined {.sourceCode .js} const verified = iden3.protocols.login.verifySignedPacket(nonceDB, origin, signedPacket); Rationale The following document contains references to similar protocols on which our login protocol relies on or takes inspiration from. Signature format Use JSON to encode the object that will be signed. JSON Signing formats https://medium.facilelogin.com/json-message-signing-alternatives-897f90d411c JSON Web Signature (JWS) Doesn\u2019t need canonicalization Allows signing arbitrary data (not only JSON) Widely used JSON Cleartext Signature (JCS) Concise Binary Object Representation (CBOR) Object Signing https://matrix.org/docs/spec/appendices.html#signing-json Matrix JSON Signing Allows having multiple signatures with different protocols for a single JSON Possible attacks See WebAuth API, FIDO Threat analysis References https://en.wikipedia.org/wiki/OpenID https://en.wikipedia.org/wiki/OpenID_Connect https://en.wikipedia.org/wiki/IndieAuth https://fidoalliance.org/how-fido-works/ WebAuth API https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API https://w3c.github.io/webauthn/ https://www.w3.org/TR/webauthn/ Demo: https://www.webauthn.io/ FIDO Security guarantees and how they are achieved: https://fidoalliance.org/specs/fido-v2.0-id-20180227/fido-security-ref-v2.0-id-20180227.html#relation-between-measures-and-goals FIDO Threat analysis and mitigations: https://fidoalliance.org/specs/fido-v2.0-id-20180227/fido-security-ref-v2.0-id-20180227.html#threat-analysis Currently (2018-01-08) there\u2019s no support for iOS (Safari): https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API#Browser_compatibility Criticism: https://www.scip.ch/en/?labs.20180424 Example code of server verification: https://github.com/duo-labs/webauthn/blob/fa6cd954884baf24fc5a51656ce21c1a1ef574bc/main.go#L336 https://w3c.github.io/webauthn/#verifying-assertion Appendix The FIDO protocols security goals: [SG-1] Strong User Authentication: Authenticate (i.e. recognize) a user and/or a device to a relying party with high (cryptographic) strength. [SG-2] Credential Guessing Resilience: Provide robust protection against eavesdroppers, e.g. be resilient to physical observation, resilient to targeted impersonation, resilient to throttled and unthrottled guessing. [SG-3] Credential Disclosure Resilience: Be resilient to phishing attacks and real-time phishing attack, including resilience to online attacks by adversaries able to actively manipulate network traffic. [SG-4] Unlinkablity: Protect the protocol conversation such that any two relying parties cannot link the conversation to one user (i.e. be unlinkable). [SG-5] Verifier Leak Resilience: Be resilient to leaks from other relying parties. I.e., nothing that a verifier could possibly leak can help an attacker impersonate the user to another relying party. [SG-6] Authenticator Leak Resilience: Be resilient to leaks from other FIDO Authenticators. I.e., nothing that a particular FIDO Authenticator could possibly leak can help an attacker to impersonate any other user to any relying party. [SG-7] User Consent: Notify the user before a relationship to a new relying party is being established (requiring explicit consent). [SG-8] Limited PII: Limit the amount of personal identifiable information (PII) exposed to the relying party to the absolute minimum. [SG-9] Attestable Properties: Relying Party must be able to verify FIDO Authenticator model/type (in order to calculate the associated risk). [SG-10] DoS Resistance: Be resilient to Denial of Service Attacks. I.e. prevent attackers from inserting invalid registration information for a legitimate user for the next login phase. Afterward, the legitimate user will not be able to login successfully anymore. [SG-11] Forgery Resistance: Be resilient to Forgery Attacks (Impersonation Attacks). I.e. prevent attackers from attempting to modify intercepted communications in order to masquerade as the legitimate user and login to the system. [SG-12] Parallel Session Resistance: Be resilient to Parallel Session Attacks. Without knowing a user\u2019s authentication credential, an attacker can masquerade as the legitimate user by creating a valid authentication message out of some eavesdropped communication between the user and the server. [SG-13] Forwarding Resistance: Be resilient to Forwarding and Replay Attacks. Having intercepted previous communications, an attacker can impersonate the legal user to authenticate to the system. The attacker can replay or forward the intercepted messages. [SG-14] (not covered by U2F) Transaction Non-Repudiation: Provide strong cryptographic non-repudiation for secure transactions. [SG-15] Respect for Operating Environment Security Boundaries: Ensure that registrations and private key material as a shared system resource is appropriately protected according to the operating environment privilege boundaries in place on the FIDO user device. [SG-16] Assessable Level of Security: Ensure that the design and implementation of the Authenticator allows for the testing laboratory / FIDO Alliance to assess the level of security provided by the Authenticator.","title":"Login protocol"},{"location":"services/login-protocol/#login-protocol","text":"","title":"Login Protocol"},{"location":"services/login-protocol/#login-protocol_1","text":"The login protocol is based on the signature protocol, in which a user signs a packet using an authorized kSign key. For the login case, the user desires to assert a particular identity (an ethereum address in this case) to a server so that they are allowed access into the service while being identified.","title":"Login protocol"},{"location":"services/login-protocol/#assumptions","text":"Secure connection between Wallet and Server. Secure connection between Web Client and Server. Wallet authenticates the Server in the connection. Web Client authenticates the Server in the connection.","title":"Assumptions"},{"location":"services/login-protocol/#what-is-needed","text":"Server authenticates the Ethereum Address and Ethereum Name from the Wallet. The user transfers the authentication from the Wallet to the Web Client.","title":"What is needed"},{"location":"services/login-protocol/#protocol-flow","text":"Challenges contain a cryptographic nonce and have a timeout that indicates the validity of the nonce in the challenge. A signed challenge with a timed out nonce must be rejected by the server. The server must store a list of not timed out nonces that haven\u2019t been signed yet to guarantee freshness. A cryptographic nonce must be securely generated and long enough to avoid colisions (we use 256 bits).","title":"Protocol flow"},{"location":"services/login-protocol/#signature-protocol-v01-spec","text":"A signature may be requested as follows: { header: { typ: iden3.sig.v0_1 } body: { type: TYPE data: DATA } } The user will generate a packet following the signature protocol specification, that may contain data from a signature request, or may be made from scratch. The packet contains a header and a payload, and is serialized and signed following the JWS standard . Usually the form will be filled by the user, and data will be copied from a request. The structure of the data and form in the payload are specified by the type (what is being signed) in the payload. The rest of the elements are specified by the typ (signature packet) in the header. JWS_PAYLOAD = { type: TYPE data: DATA form: FORM ksign: str # ksing public key in compressed form proofKSing: proofClaim # Proof of authorize k sign claim (which contains the public key in compressed form) } JWS_HEADER = { typ: iden3.sig.v0_1 iss: str # Ethereum Address iat: uint # issued at time, unix timestamp exp: uint # expiration time, unix timestamp alg: ? # algorithm } JWS_SIGN(JWS_HEADER, JWS_PAYLOAD) Each Signature request type has a view representation for the user, where the data and form are presented. Some of the values may be hidden from the user when necessary, but only if doing so doesn\u2019t compromise the security of the user. In the request view, the user has the ability to pick some elements of the form . ksign is the compressed public key of a secp256k ECDSA key pair. The proofKSing contains a KSign Authorize Claim for a secp256k public key. As JWS_HEADER.alg we will use a custom algorithm (not defined in the JWS standard): \u201cEK256K1\u201d, which is ECDSA with secp256k1 curve and keccak as hash function, the same signature algorithm configuration used in Ethereum.","title":"Signature Protocol v0.1 spec"},{"location":"services/login-protocol/#auxiliary-data-structures","text":"proofClaim: { signature: signature # Relay root + date signed by relay date: uint leaf: claim proofs: proofClaimPartial[] } proofClaimPartial: { mtp0: mtp # merkle tree proof of leaf existence mtp1: mtp # merkle tree proof of leaf non-existence root: key # merkle tree root aux: nil | { ver: uint, era: uint, idAddr: str } # Necessary data to construct SetRootClaim from root } Usually the relay returns the proofClaim data structure to prove that a claim is valid and is in the merkle tree.","title":"Auxiliary data structures"},{"location":"services/login-protocol/#identity-assertion-v01-spec","text":"payload: type: iden3.iden_assert.v0_1 data: { challenge: nonce # 256 bits in base64 timeout: uint # seconds origin: str # domain } form: { ethName: str # ethereumName proofAssignName: proofClaim # proof of claim Assign Name for ethName } A session id, if necessary, can be computed from the challenge. This session id can be used to link the communication between the web service and the wallet service. view: type: Identity Assertion data: { origin: str # domain } form: { ethName: str # ethereum name }","title":"Identity Assertion v0.1 spec"},{"location":"services/login-protocol/#algorithms","text":"Here we show an overview of the algorithms steps used for verification of the proofs and signatures used in the login protocol. The following algorithms consider the case in which there is a only a single trusted entity (identified by relayPk ) that acts as a relay and as a domain name server.","title":"Algorithms"},{"location":"services/login-protocol/#signature-verification-algorithm","text":"VerifySignedPacket(jwsHeader, jwsPayload, signature, relayPk): 1. Verify jwsHeader.typ is 'iden3.sig.v0_1' 2. Verify jwsHeader.alg is 'EK256K1' 3. Verify that jwsHeader.iat <= now() < jwsHeader.exp 4. Verify that jwsPayload.ksign is in jwsPayload.proofKSign.leaf 5. Verify that jwsHeader.iss is in jwsPayload.proofKSign 6. Verify that signature of JWS(jwsHeader, jwsPayload) by jwsPayload.ksign is signature 7. VerifyProofOfClaim(jwsPayload.proofKSign, relayPk) In 4. we verify that the ksign used to sign the packet is authorized by the user, identified by jwsHeader.iss ethereum address.","title":"Signature verification algorithm"},{"location":"services/login-protocol/#iden-assert-verification-algorithm","text":"VerifyIdenAssertV01(nonceDB, origin, jwsHeader, jwsPayload, signature, relayPk): 1. Verify jwsPayload.type is 'iden3.iden_assert.v0_1' 2. Verify jwsPayload.data.origin is origin 3. Verify jwsPayload.data.challenge is in nonceDB and hasn't expired, delete it 4. Verify that jwsHeader.iss and jwsPayload.form.ethName are in jwsPayload.proofAssignName.leaf 5. VerifyProofOfClaim(jwsPayload.form.ethName, relayPk)","title":"Iden Assert verification algorithm"},{"location":"services/login-protocol/#proofofclaim-verification","text":"VerifyProofOfClaim(p, relayPk): 1. Verify signature of p.proofs[-1].root by relayPk is p.signature let leaf = p.leaf 2. loop for each proof in p.proofs: 2.1 Verify proof.mtp0 is existence proof 2.2 Verify proof.mtp0 with leaf and proof.root 2.3 Verify proof.mtp1 is non-existence proof 2.4 Verify proof.mtp1 with ClaimIncrementVersion(leaf) and proof.root leaf = NewClaimSetRootClaim(p.root, p.aux.ver, p.aux.era, p.aux.ethAddr)","title":"ProofOfClaim verification"},{"location":"services/login-protocol/#iden3js-protocols","text":"","title":"iden3js - protocols"},{"location":"services/login-protocol/#login-identity-assertion","text":"Wallet Service + + | signatureRequest | | <-------------------------------------+ | | | | +---+ | | | | | |sign packet | | | | | <---+ | | signedPacket | | +-------------------------------------> | | | | +---+ | | verify | | | signedPacket| | | | | | +---> | | | | ok | | <-------------------------------------+ | | | | | | | + + Read the login protocol specification here .","title":"Login (Identity Assertion)"},{"location":"services/login-protocol/#define-new-noncedb","text":"const nonceDB = new iden3.protocols.NonceDB();","title":"Define new NonceDB"},{"location":"services/login-protocol/#generate-new-request-of-identity-assert","text":"input nonceDB : NonceDB class object origin : domain of the emitter of the request timeout : unixtime format, valid until that date. We can use for example 2 minutes ( 2*60 seconds) output signatureRequest : Object {.sourceCode .js} const signatureRequest = iden3.protocols.login.newRequestIdenAssert(nonceDB, origin, 2*60); The nonce of the signatureRequest can be getted from: const nonce = signatureRequest.body.data.challenge; // nonce is the string containing the nonce value We can add auxiliar data to the nonce in the nonceDB only one time: const added = nodeDB.addAuxToNonce(nonce, auxdata); // added is a bool confirming if the aux data had been added","title":"Generate New Request of Identity Assert"},{"location":"services/login-protocol/#sign-packet","text":"input signatureRequest : object generated in the newRequestIdenAssert function userAddr : Eth Address of the user that signs the data packet ethName : name assigned to the userAddr proofOfEthName : proofOfClaim of the ethName kc : iden3.KeyContainer object ksign : KOperational authorized for the userAddr proofOfKSign : proofOfClaim of the ksign expirationTime : unixtime format, signature will be valid until that date output signedPacket : String {.sourceCode .js} const expirationTime = unixtime + (3600 * 60); const signedPacket = iden3.protocols.login.signIdenAssertV01(signatureRequest, usrAddr, ethName, proofOfEthName, kc, ksign, proofOfKSign, expirationTime);","title":"Sign Packet"},{"location":"services/login-protocol/#verify-signed-packet","text":"input nonceDB : NonceDB class object origin : domain of the emitter of the request signedPacket : object generated in the signIdenAssertV01 function output nonce : nonce object of the signedPacket, that has been just deleted from the nonceDB when the signedPacket is verified. If the verification fails, the nonce will be undefined {.sourceCode .js} const verified = iden3.protocols.login.verifySignedPacket(nonceDB, origin, signedPacket);","title":"Verify Signed Packet"},{"location":"services/login-protocol/#rationale","text":"The following document contains references to similar protocols on which our login protocol relies on or takes inspiration from.","title":"Rationale"},{"location":"services/login-protocol/#signature-format","text":"Use JSON to encode the object that will be signed.","title":"Signature format"},{"location":"services/login-protocol/#json-signing-formats","text":"https://medium.facilelogin.com/json-message-signing-alternatives-897f90d411c JSON Web Signature (JWS) Doesn\u2019t need canonicalization Allows signing arbitrary data (not only JSON) Widely used JSON Cleartext Signature (JCS) Concise Binary Object Representation (CBOR) Object Signing https://matrix.org/docs/spec/appendices.html#signing-json Matrix JSON Signing Allows having multiple signatures with different protocols for a single JSON","title":"JSON Signing formats"},{"location":"services/login-protocol/#possible-attacks","text":"See WebAuth API, FIDO Threat analysis","title":"Possible attacks"},{"location":"services/login-protocol/#references","text":"https://en.wikipedia.org/wiki/OpenID https://en.wikipedia.org/wiki/OpenID_Connect https://en.wikipedia.org/wiki/IndieAuth https://fidoalliance.org/how-fido-works/","title":"References"},{"location":"services/login-protocol/#webauth-api","text":"https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API https://w3c.github.io/webauthn/ https://www.w3.org/TR/webauthn/ Demo: https://www.webauthn.io/","title":"WebAuth API"},{"location":"services/login-protocol/#fido-security-guarantees-and-how-they-are-achieved","text":"https://fidoalliance.org/specs/fido-v2.0-id-20180227/fido-security-ref-v2.0-id-20180227.html#relation-between-measures-and-goals","title":"FIDO Security guarantees and how they are achieved:"},{"location":"services/login-protocol/#fido-threat-analysis-and-mitigations","text":"https://fidoalliance.org/specs/fido-v2.0-id-20180227/fido-security-ref-v2.0-id-20180227.html#threat-analysis Currently (2018-01-08) there\u2019s no support for iOS (Safari): https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API#Browser_compatibility","title":"FIDO Threat analysis and mitigations:"},{"location":"services/login-protocol/#criticism","text":"https://www.scip.ch/en/?labs.20180424","title":"Criticism:"},{"location":"services/login-protocol/#example-code-of-server-verification","text":"https://github.com/duo-labs/webauthn/blob/fa6cd954884baf24fc5a51656ce21c1a1ef574bc/main.go#L336 https://w3c.github.io/webauthn/#verifying-assertion","title":"Example code of server verification:"},{"location":"services/login-protocol/#appendix","text":"","title":"Appendix"},{"location":"services/login-protocol/#the-fido-protocols-security-goals","text":"","title":"The FIDO protocols security goals:"},{"location":"services/login-protocol/#sg-1","text":"Strong User Authentication: Authenticate (i.e. recognize) a user and/or a device to a relying party with high (cryptographic) strength.","title":"[SG-1]"},{"location":"services/login-protocol/#sg-2","text":"Credential Guessing Resilience: Provide robust protection against eavesdroppers, e.g. be resilient to physical observation, resilient to targeted impersonation, resilient to throttled and unthrottled guessing.","title":"[SG-2]"},{"location":"services/login-protocol/#sg-3","text":"Credential Disclosure Resilience: Be resilient to phishing attacks and real-time phishing attack, including resilience to online attacks by adversaries able to actively manipulate network traffic.","title":"[SG-3]"},{"location":"services/login-protocol/#sg-4","text":"Unlinkablity: Protect the protocol conversation such that any two relying parties cannot link the conversation to one user (i.e. be unlinkable).","title":"[SG-4]"},{"location":"services/login-protocol/#sg-5","text":"Verifier Leak Resilience: Be resilient to leaks from other relying parties. I.e., nothing that a verifier could possibly leak can help an attacker impersonate the user to another relying party.","title":"[SG-5]"},{"location":"services/login-protocol/#sg-6","text":"Authenticator Leak Resilience: Be resilient to leaks from other FIDO Authenticators. I.e., nothing that a particular FIDO Authenticator could possibly leak can help an attacker to impersonate any other user to any relying party.","title":"[SG-6]"},{"location":"services/login-protocol/#sg-7","text":"User Consent: Notify the user before a relationship to a new relying party is being established (requiring explicit consent).","title":"[SG-7]"},{"location":"services/login-protocol/#sg-8","text":"Limited PII: Limit the amount of personal identifiable information (PII) exposed to the relying party to the absolute minimum.","title":"[SG-8]"},{"location":"services/login-protocol/#sg-9","text":"Attestable Properties: Relying Party must be able to verify FIDO Authenticator model/type (in order to calculate the associated risk).","title":"[SG-9]"},{"location":"services/login-protocol/#sg-10","text":"DoS Resistance: Be resilient to Denial of Service Attacks. I.e. prevent attackers from inserting invalid registration information for a legitimate user for the next login phase. Afterward, the legitimate user will not be able to login successfully anymore.","title":"[SG-10]"},{"location":"services/login-protocol/#sg-11","text":"Forgery Resistance: Be resilient to Forgery Attacks (Impersonation Attacks). I.e. prevent attackers from attempting to modify intercepted communications in order to masquerade as the legitimate user and login to the system.","title":"[SG-11]"},{"location":"services/login-protocol/#sg-12","text":"Parallel Session Resistance: Be resilient to Parallel Session Attacks. Without knowing a user\u2019s authentication credential, an attacker can masquerade as the legitimate user by creating a valid authentication message out of some eavesdropped communication between the user and the server.","title":"[SG-12]"},{"location":"services/login-protocol/#sg-13","text":"Forwarding Resistance: Be resilient to Forwarding and Replay Attacks. Having intercepted previous communications, an attacker can impersonate the legal user to authenticate to the system. The attacker can replay or forward the intercepted messages.","title":"[SG-13]"},{"location":"services/login-protocol/#sg-14","text":"(not covered by U2F) Transaction Non-Repudiation: Provide strong cryptographic non-repudiation for secure transactions.","title":"[SG-14]"},{"location":"services/login-protocol/#sg-15","text":"Respect for Operating Environment Security Boundaries: Ensure that registrations and private key material as a shared system resource is appropriately protected according to the operating environment privilege boundaries in place on the FIDO user device.","title":"[SG-15]"},{"location":"services/login-protocol/#sg-16","text":"Assessable Level of Security: Ensure that the design and implementation of the Authenticator allows for the testing laboratory / FIDO Alliance to assess the level of security provided by the Authenticator.","title":"[SG-16]"}]}